[삼각함수] hypotenuse=빗변 / opposite=높이 / adjacent=밑변
-피타고라스의 정리 : h^2 = a^2 + o^2 //(밑변제곱 + 높이제곱 = 빗변제곱)
-cos,sin,tan은 결국 삼각형의 변에 대한 비율을 나타낸다.

-여기서 더 발전시켜, 그저 90도 이내의 일반적인 삼각형이 아니라 Unit Circle의 개념에서 삼각함수를 바라보자.
그러면 90도를 초과하는 cos과 sin의 값을 얻을수있으며 음수의 값도 표현할 수 있다.

-라디안 : 호의 길이가 1이 되는 각도
그러면 1rad이 몇도인가? 사실 '도'라는 개념을 쓰지않으려고 만든 단위라서 의미 없긴한데, 57도 정도된다.

<알아두면 좋은 삼각함수 특징들>
cos(세타) = cos(-세타) : 짝함수,우함수,even
sin(세타) = -sin(-세타) : 홀함수,기함수,odd

<삼각함수의 역함수> arcsin / arccos / arctan
비율을 알고, 그 사이의 각도를 알고싶을때 사용 ex) arccos(a) = 세타
arccos을 구할때 세타값은 0~pi
arcsin은 -pi/2 ~ pi/2 사이의 값이 나온다

-cos법칙 //궁금하면 검색해보자. 외울필요는 없고 필요할때마다 기억해서 검색할순 있어야한다.
a^2 = b^2+c^2-2bc*cos(A) // 두 변의 제곱에서 사잇각cos과 그 두 변의 곱의 2배를 빼면, 남은 변의 제곱과 같아진다
=> a = b*cos(C)+c*cos(B) // b,B와 c,C는 마주보는 각과 변이다.

<cos덧셈정리> // ! ㅋㅋㅅㅅ,ㅅㅋㅋㅅ 회전행렬에 자주사용
cos(a+b) = cos(a)cos(b) - sin(a)sin(b)
cos(a-b) = cos(a)cos(b) + sin(a)sin(b)
sin(a+b) = sin(a)cos(b) + cos(a)sin(b)
sin(a-b) = sin(a)cos(b) - cos(a)sin(b)

[벡터]
벡터: 크기+방향 데이터를 모두 담고있다.
<벡터의성질>
1.벡터의 덧셈: 각 성분끼리 더한다.// x성분끼리 더하거나 y성분끼리 더하거나
=>기하학적으로 보면 재밌는게, 두 벡터를 끝에서 끝으로 이어서 도달하는 곳이 벡터의 덧셈이다.
2.벡터의 곱셈: 사실 벡터간의 곱셈이란 존재하지 않는다. 엄밀히말하면 스칼라와 벡터의 곱이 존재할뿐이다.

-벡터의크기: 피타고라스 법칙을 이용해 구한다. h^2 = a^2 + o^2
간단한 원리다. 3차원 이상이 되면 식이 복잡해지기는 하나, 결국에는 피타고라스를 여러번 쓰는것일뿐

-단위벡터: 벡터는 방향과 크기를 담고있는 데이터라 했다. 단위벡터란 그중 방향 데이터만을 유지한채 크기를 1로 만든 벡터를 의미한다.
=>왜 굳이 크기데이터를 날리는가? =크기데이터를 일부러 날려서 패킷절약을 생각하면 된다. 그냥 여기저기 갖다넣기 편하게 가공한것.

<벡터의내적> 
=|a||b|cos세타, 계산시 XaXb + YaYb와 같은 결과를 얻을수있음. (각성분끼리의 곱들의 합과 같다.)
기본적으로 cos계산은 오래걸리는데, 단순히 스칼라 연산으로 해결할수있다.
주로 두 벡터사이의 '사이각에 달린 계산'에 용이하다.
!ex)백어택(a와b의 스칼라연산을통해 빠르게, cos세타가 0보다 큰지 작은지(=세타가 90이상인지 이하인지)(=앞에있는지 뒤에있는지) 알아낼수있다.)

<벡터의외적> !! Va와Vb 둘모두에게 수직인 벡터를 의미
결과물만 보면, |a||b|sin세타 Va //=스칼라*벡터
3차원 이상으로 가야 의미가있다.
보통 왼손법칙을 통해 방향을 지정하며, 해당 방향을 지니고 크기는 |a||b|sin세타를 갖는다.
이것도 간단히 계산하는법이 있긴한데 외울정도는 아님(실사용시에도 Cross를 사용하니까)
-외적은 내적과 다르게 교환법칙이 성립하지 않는다.
=>애당초 내적은 |a||b|cos세타 이기에 바꿔도 상관없지만 외적은 |a||b|sin세타 Va 에서 va의 방향때문에 문제가됨.(|a||b|sin세타는 상관없다.)
주로 법선을 구할때 사용 // 두벡터 모두에게 수직인 벡터를 구하는게 중요하다는말.
ex) NavMesh: Va와 Vb가 있다할때, 목표위치가 두 벡터사이에 있는지 판단할때 사용(각 'a,목표','b,목표'의 외적으로 나온 두 법선의 단위벡터의 방향을 보면 판별가능)
ex) 둥글게 돌아가는 스킬쿨타임바에도 사용. 특정 각도 외부에 있다면 회색으로 칠하는 그것.
! =>즉, 특정 두개의 각도 안에 있는지 밖에 있는지 판단하는데 사용된다.

사실 벡터는 위처럼 크기와각도를 갖는 '기하벡터'외에도 위치를 나타내는 '위치벡터'로도 활용된다. //게임엔진 몇번 만져보면 바로이해될거다.

[행렬] // 행(row),열(col) = ㄱ
스칼라값이 들어있는 2차원 배열

-행렬의덧셈: 우선적으로 행렬크기가 같아야함. 그렇다면 각 인자끼리 더한다.
-행렬과스칼라의 곱셈: 각 인자에 스칼라값을 곱해준다.

-행렬과행렬의 곱셈: 'A의열'과 'B의행'의 크기가 같아야한다. //A[m,n] * B[n,p]
그렇게 나온 결과물은 'A의행'과'B의열'의 크기를 같는다. //C[m,p]
C의 인자 C(ij)의 값은, 시그마k~{A(ik)*B(kj)}다. //쉽게말해 해당C위치의 행렬중, 각각 A는행,B는열의 값들을 곱하고 전부더하면 된다.
// 귀찮으면 인터넷에서 그림한번보면 바로 이해될것.
// 내적으로도 표현가능하다. Dot(A의행,B의열)

<행렬의 교환/결합법칙이 유효한가?>
-교환: 당연히 안된다. A의행,B의열 != A의열,B의행
-결합: 가능하다. (AB)C = A(BC)
결합이 중요한 이유, 만약 AB=I인걸 알고있을때, MAB=M이라는걸 간단히 구할수있고,
응용하면 MA에 B를 곱하면 M으로 되돌린다 즉,A의곱을 무효화시킬수있다.(역행렬) -그러나 역행렬이 존재하지 않을수도있음

<행렬의 특징>
-대각행렬: Cii, Cjj, Cxx처럼 행렬이 같은 대각선 배열
-단위행렬: 대각요소들이 모두 1이고 나머지는 전부 0인 배열, I(Identity)
단위행렬이 특별한 이유: A행렬에 단위행렬을 곱해주면, '자기자신이 나온다'.
또한 AI=A가 나오듯, IA=A가 나온다.

기본적으로 게임내 연산에서는 M(4x4)로 4개의 행과 열을 사용함. (x,y,z와 차원을위한1)

<행렬식> Det: 역행렬이 존재하는지 확인하고 찾아내는 공식
Det=ad-bc가 0이 아니면 역행렬 존재.//텍스트로 설명힘드니 인터넷 찾아볼것

<게임에서 구할수있는 역행렬>
-전치행렬 T(Transpose) : 행과열을 뒤집은 행렬
-직교행렬 : 행벡터와 열벡터가 직교하는(내적시 0) 행렬 > 직교행렬인 M과 M의 전치행렬의 곱은 I가 나온다.
> 전치를 해서 I가 나왔다는것은, 직교행렬의 전치행렬이 직교행렬의 역행렬이라는것! (즉, 아까처럼 복잡한 행렬식을 거칠필요 없이 간단히 역행렬을 구할수 있다.)
=>수학적으로는 특이한상황이나, 게임상에서는 모든 벡터를 직교하게 두는경우가 많기에 굉장히 자주나오고 유용하다. ex)카메라 좌표계

[Scale,Rotation,Translation 변환 행렬]
벡터와 행렬의 곱= 벡터를 1X3인 행렬이라 생각하고 행렬간곱(앞열*뒤행)을 시행한다. ex) (1,3) X (3,3) = (3,3)
X= xm11+ym21+zm31
Y= xm12+ym22+zm32
Z= xm13+ym23+zm33
!벡터를 변화시킬때 중요한것 = S.R.T //Scale, Rotation, Trnaslation

게임차원에서는 3차원만으로 공간의 이동을 표현할수없다. 그래서 임의의 1차원을 추가해 4차원(4X4행렬)을 사용한다.
=>동차좌표계
X= xm11+ym21+zm31+m41
Y= xm12+ym22+zm32+m42
Z= xm13+ym23+zm33+m43
W= xm14+ym24+zm34+m44
사용시 w는 주로 1로 설정한다. 

<Translation행렬>
(a,b,c) 방향으로 움직이고 싶을때 사용하는 Translation행렬은 다음을 만족해야하고//(x,y,z) -> (x+a,y+b,z+c)
X= xm11+ym21+zm31+m41 = x+a
Y= xm12+ym22+zm32+m42 = y+b
Z= xm13+ym23+zm33+m43 = z+c
W= xm14+ym24+zm34+m44 = 1

그렇다면
[1,0,0,0]
[0,1,0,0] 
[0,0,1,0]
[a,b,c,1] 이 된다.

어떠한 벡터든 위 형태의 행렬과 곱해지면 (a,b,c)방향으로 이동하는것처럼 보이게됨.

<Scale행렬>
각각(a,b,c) 배로 커지게 만들고싶다면 //(x,y,z) -> (xa,yb,zc)
X= xm11+ym21+zm31+m41 = xa
Y= xm12+ym22+zm32+m42 = yb
Z= xm13+ym23+zm33+m43 = zc
W= xm14+ym24+zm34+m44 = 1

[a,0,0,0]
[0,b,0,0]
[0,0,c,0]
[0,0,0,1]
//그러나 만들어진 모델의 중심점에 따라, 의도치 않은방향으로 커질수있기에 무조건적인건 아님, ex) 중심점이 발밑 root가 아닌경우

<Rotation행렬> -난이도있음
하나의 축을 기준으로 회전하고 싶다 (yaw,pitch,roll)
기존a(x,y)인 점의 각을 A, 목표b()의 각을 세타라할때
(x,y) -> (xCos세타-SinA, xSin세타+yCosA)
z축 고정인 경우를 예로보면
X= xm11+ym21+zm31+m41 = xCos세타-SinA
Y= xm12+ym22+zm32+m42 = xSin세타+yCosA
Z= xm13+ym23+zm33+m43 = z
W= xm14+ym24+zm34+m44 = 1

[cos세타,-sin세타,	0,	0]
[sin세타, cos세타,	0,	0]
[0,		0,			1,	0]
[0,		0,			0,	1]
계산식이 복잡하므로 필요시에는 인터넷을 검색하자!
//이경우 자전과 같은 움직임을 취한다.