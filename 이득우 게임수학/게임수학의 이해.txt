[공간의 수학]
-다음과 같이 수학적으로 이해하는것이 좋을거다.
벡터: 벡터공간의 원소
스칼라: 체집합의 원소

-렌더링 파이프라인 = 공간변환 체재 (물체를 공간에 올리고 카메라가 바라보며 이것을 모니터에 투영하는 과정)
ex)모델링 변환->뷰 변환->원근투영 변환 (로컬공간-월드공간-뷰공간-사영공간)
이렇게 선형변환을 지시하는 명령어를 '행렬'이라고 이해하면 편하다. //위 모델링,뷰,원근투영 변환 모두 하나의 행렬을 적용시키는것이다.

[물체의 수학1: 이동변환의 구현원리]
-물체에 대한 수학? : 게임속의 가상공간 체계와 물체를 구성하는데 사용하는 수학
-게임공간에서 벡터는 1.물체를 표현하는 공간(transform같이), 2.이동을 위한공간(방향벡터)를 구분하여 사용해야한다.
게임을 구성하는 모든 공간은 4차원으로 구성되어 있다. (3차원+확장된1차원)
예를들면 월드공간에 로컬공간을 담는다고 했을때, 담겨진 월드공간에서 나머지 하나의 확장차원을 통해 로컬공간에 방향성을 주는것
//쉽게말해 월드스페이스와 로컬스페이스의 차이라고 보면된다. 그냥 이말한것.

[물체의 수학2: 삼각형과 정점]
점+벡터=점
점-점=벡터
벡터+벡터=벡터
점+점?=불가능
-아핀조합: 일반적으로 점과 점은 더할수 없다. 그러나 각 점에 a와b라는 계수를 붙여주면 a점+b점=a+b를 얻을수있다.(수식생략)
이때 a+b=1이라면, 두점을 더했을때 항상 점을 얻을수 있다.
여기서 b=1-a를라고 수식화하여 사용하면, a값과 무관하게 언제나 아핀공간의 점을 얻을수 있다는 결론을 얻을수 있다.
aP1+(1-a)P -> p2+a(P1-P2)가 되고, 이는 곧 점-벡터이니 점을 얻어낸것

!=>결과적으로, 두 점을 조합해 새로운 점을 만들어내는 공식을 '아핀조합'이라 한다.

두점의 조합으로 만들수 있는 새로운 점은 계수a에 따라 만들어진다. 그리고 이 점들을 모으면 직선(Line)이 된다. //생성되는점은 a가0이면 점이p2가 되고, a가1이면 p1이 된다.
즉, p2에서 p1을 향하는 무한한 직선이 생김.
그런데 여기서 p2는 고정되어 있음=>즉, 반직선(Ray)가 생긴다. 이게 라인트레이싱, 레이트레이싱의 그것이다.

면을 생성하는 수학: 3개의 점을 사용. 똑같이 a+b+c=1임을 이용하여 만드는것이다.
!즉 3개의 점을통해, 새로운 점의 범위(면)을 구할수 있고, 이것들을 색칠하는 것이 '게임그래픽'이며, 그러한 면의집합의 정보를 담고있는 것이 '메쉬'다.

또한 삼각형을 구성하는 3개의 점에다 색상,UV,노말,탄젠트같은 데이터를 담는다면, 무게중심 좌표를 통해 자동으로 삼각형내의 픽셀들에 각각 색을 칠할수있고 더욱 자세한 묘사가 가능하다.
이렇게 데이터를 담고있는 점을 정점(Vertex)라고한다.

!!결국 게임에서 화면을 그리는 과정: 물체를 3개의 vertex로 구성된 삼각형으로 분리하고, 이것을 각각그려 화면을 채우는것
=>이 과정을 렌더링파이프라인 이라고함

이런 렌더링파이프라인과정에서도 자기만의 특색을 살리기위해 변화를 줄수있는 함수가 있다.
그것이 바로 '셰이더'이다.
VertexShader: 각 Vertex들의 최종데이터를 결정하는 함수
PixelShader: 삼각형 내부를 구성하는 각 픽셀들의 최종 색상을 결정하는 함수

[물체의 수학3: 벡터의 내적과 외적]
게임과정에서는 메쉬가 직접 움직이는 것이아닌, 메쉬의 공간이 움직이는 것이라고 하였다.
이것을 표현하기 위해서는 게임로직,즉 벡터의 수학이 필요하다.
-Transform: 크기,회전,위치를 순서대로 조합한 행렬->이를통해 쉽고빠르게 렌더링을 진행할수있다.

-벡터의연산
1.벡터+벡터, 2.벡터*스칼라, 3.벡터의 내적, 4.벡터의 외적
//스칼라= 사칙연산이 가능한 수 집합의 원소(실수)

1.v1+v2=(x1+x2,y1+y2) 
2.a*v=(ax,ay) //벡터의 고유 성질(기울기)를 유지한 상태로 크기를 조절하는 동작이라 볼수있다.
선형조합: 1과2를 조합하여 새로운 벡터를 만들어내는것

3.내적: dot(v1,v2) = x1x2 + y1y2 + z1z2
//각축을 곱하고 전부를 더한다.
두벡터의 직교성을 판단하는데 사용

4.외적: cross(v1,v2) = v1 X v2 = (y1z2-y2z1, z1x2-z2x1, x1y2-x2y1)
두벡터의 평행성을 판별하는데 사용

[회전의 수학1: 삼각함수와 회전변환]
게임속의 모든 움직임은 공간의 움직이라했다. 공간의 변환이란 즉, 표준기저벡터를 변경시켜 새로운 공간을 창조하는것이다.
-회전변환의 원리: 회전변환을 적용해도 물체의 외형은 변하지 않는다.= 표준기저벡터가 가지고있던 성질을 그대로 유지시켜 변환시켜준다.
<3차원공간에서의 회전>
1.축-각회전: 내적과 외적을 사용해 계산
단점- 직관적이지않고 행렬로 변환이 어렵기에 렌더링파이프라인의 흐름이 끊기게됨
2.오일러 각회전: 하나의 회전을 Roll,Yaw,Pitch 3개의 회전으로 분해해서 계산
단점- 쉽지만 3개로 분해해야되서 부드러운 움직임을 표현하기 어려움(비효율)
단점2- 한축의 회전이 증발하는 짐벌락 현상이 발생

=>이러한 장단점들을 보완하기 위해 사원수(Quaternion)을 만들었다.

[회전의 수학2: 사원수]
4개의 원소로 구성된 수 //4개라는게 생소하지만 복소수(a+bi)는 2개라는걸 생각해보면 이해가 될것이다.
ex)-실수: a
-사원수: a + bi + cj + dk //a=실수부, 그뒤는 허수부

! 회전이란 '크기가 1인 수와의 곱'이다.
실수의 곱셈: a*1 = a //0도 회전하였다.
a*-1 = -a //180도 회전하였다.
사실 실수는 하나의 선분위에 있는 수이기에 회전의 큰 의미가 없다.

그러나 평면에서 표현하는 수라면 어떨까?(복소수와 복소평면)
크기가 1인 사원수의 곱셈은 (계산시)신기하게도 내적과 외적으로 표현된다.
=>크기가 1인사원수와의 곱은 4차원공간에서의 회전을 의미한다. //크기가 1인 사원수? = cos세타 + sin세타v

<아무튼그래서 게임엔진에서는 사원수를 어떻게 사용해 회전을 구현하는가?>
사원수를 사용해 빠르게 벡터를 회전시킬수 있다.
또한 사원수는 행렬로 변환이 용이하다.
축-각방식이고 절반의 각으로 파생되기에 일반인들이 직관적으로 사용하긴 어려움
그렇기에 오일러각을 사용

! 게임로직(Rotator)<->트랜스폼 회전시스템(Quaternion -> Local Axes)<->렌더링로직(Matrix)