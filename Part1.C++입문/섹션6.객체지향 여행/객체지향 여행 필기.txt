[ 객체지향의 시작 ] OOP : Object Oriented Programming
c++에서는 클래스와 struct의 차이가 굉장히 적다. //참조와 복사의 차이인걸로 아는데..
아무튼 C++의 클래스 선언이 기존에 알던것과 다른점이 많더라.
예를들면 클래스 내부에 public을 선언해 멤버속성과, 멤버함수를 만든다던가, 클래스의 기능함수는 ::을 통해 표시한다던가.
그리고 여기선 this가 포인터더라. 그래서 this->hp=0; 이런식으로 접근해야함.

근본은 붕어빵틀과 붕어빵이라는 점은 다르지않다.

[ 생성자와 소멸자 ]
생성자는 c#과 같이, 새로운 객체를 생성할때 호출되는 함수를 의미한다.(주로 스탯을 설정해줄수있겠다.)
그리고 소멸자는 c#과 달리 메모리를 관리하는 c++의 특징상, 메모리 해제도 필요하다. 그렇기에 사용이 끝난 객체의 메모리 연결을 x삭제하는x 역할을 한다.
//삭제하는 역할을 하지 않는다. 함수호출종료시 스택이 밀리면서 자동으로 삭제되며, 그때 소멸자가 호출이 될 뿐이다.
//스택메모리에 올라가는 순간 생성자가 호출되고, 메모리에서 삭제되는 순간 소멸자가 호출.

생성자 : 암시적생성자, 1.기본생성자, 2.복사생성자, 3.기타생성자, 타입변환생성자(이게좀 어렵다.)

[ 상속성 ]
상속문법 : class Knight : public Player
// 특이하게, 처음 class를 선언할때 앞에 public private 등이 붙지않고, 상속할때 따로 붙여주네. => '상속접근지정자라'고 나중에 다시 다루겠다.
상속받은 클래스는 [[player]knight] 이런식으로, 부모 클래스의 메모리가 먼저 할당되고, 그뒤에 자식의 추가데이터를 등록한다.

중요한건, 생성자와 소멸자다.
자식이 생성되면, 부모의 생성자와 자식의 생성자가 모두 호출된다. 소멸자도 마찬가지.
그러나 호출되는 순을 보면 부모생성-자식생성 - 자식소멸-부모소멸 인데, 이것은 메모리가 만들어지는 순서를 생각하면 이해하기 쉬울것이다.

그리고 자식과 부모의 생성자가 모두 호출 될때, 부모생성자는 기본생성자가 호출된다.
=>물론 자식생성자를 만들때, 어떤 부모생성자를 생성할지를 상속관계로 만들어주면, 부모의 기타생성자를 사용할 수도 있다.
ex) Knight (int stamina) : Player(100) {}  //강의에서는 player (int hp)의 인자로 100을 사용한거지만, 여기서 100말고 stamina를 넣을수있을듯?

[ 은닉성 ] =캡슐화 / Public Protected Priavte 
-Public : 어디서든 접근가능 :
-Protected : 나&자손들만 접근가능
-Private : 자기 내부에서만 접근가능

C++에서는 public : 이런식으로 쓰면, 다른 접근지정자(protectted,private) 이런게 나오기전까진 모두 public으로 취급한다.

-캡술화 : 연관된 데이터와 함수를 논리적으로 묶어놓은 것.

<상속접근지정자> : 자손에게 데이터를 넘길때, 
public : 부모의 유산 설계 그대로 (public->public, protected->protected) : 거의 이것만 씀
protected : 자손들만 사용할수있게 물려줌 (public->protected, protected->protected) : 딱봐도 사용법이 애매할듯
private : 지금 물려받는 애만 사용할수있게 private로 주겠다. (public->private, protected->private)
//c#처럼 상속선언할때, 접근지정자 안써주면 private로 작동함. 그걸로 오류가 발생할수있어서, 기억해놔야됨

[ 다형성 #1 ] 겉은 똑같은데, 기능이 다르다.
-오버로딩 : 함수 중복 정의 : 함수 이름의 재사용 //같은 클래스에서 여러개의 함수
-오버라이딩 : 부모의 함수를 자식 클래스에서 재정의 //다른 클래스에서 같은 함수를 재정의

<바인딩>
-정적바인딩 : 컴파일 단계에서 결정
-동적바인딩 : 실행단계에서 결정
일반함수는 정적바인딩을 기본적으로 사용한다. 즉, 일반함수로는 들어오는 매개변수의 타입에 따라 오버라이딩 된 함수를 고를수 없다는 것
동적 바인딩을 원한다면? => 가상함수(virtual)을 사용해야 한다.

[ 다형성 #2 ] 가상함수 vftable
가상함수가 추가되는 순간, 가상함수테이블(vftable)이 만들어지면서 메모리구조가 변형된다.
이걸통해서 함수가, 해당 가상함수를 불러올때 // MovePlayer라는 함수가 인자.VMove를 호출할때
가상함수의 vftable로 연결되고, 그 테이블에 의해서 해당 객체가 Player의 가상함수 player.Vmove로 갈지 Knight.VMove로 갈지 알게된다는말.
//즉, vftable은 자기객체로 가는 표지판을 들고있어서, 외부함수가 어떤 멤버함수로 가야되는지 알려준다.

순수가상함수 : 구현은 없고, 인터페이스만 알리기위한 함수 abstract
옛날방법은 virtual void VMove()=0; 이런식으로 0을 붙임. 모던C++에서는 abstract를 사용한다.

[ 초기화 리스트 ] 멤버변수의 초기화
다양한 문법이 존재한다.
1. 생성자내에서 // int _hp=100; 직접 초기화
2. 초기화 리스트
3. C++11 문법 // 클래스내에서 int _hp=100; 으로 초기화 가능. 그런데 옛날엔 이게 안됬어서, 이방법이 아닌 방법도 알아야함.

<초기화리스트>
생성자를 만들때, 원하는 부모생성자를 지정하는것처럼, 멤버변수를 초기화 시킬수 있다. ex) Knight() : Player(1), _hp(100); //부모생성자 지정에는 public, private안넣는다. 당연하지 상속이 아니라 지정이니까!
//어떻게보면 부모생성자 지정도 초기화라고 할수있을듯?
생성자 내에서 초기화 하는거랑 초기화 리스트를 사용하는 것이 비슷해보일수 있긴하나(일반변수는 별차이없음), 멤버타입이 클래스가 되는 경우 차이가 생긴다.
클래스가 다른클래스를 포함하게 되는 경우 ex) 인벤토리 클래스에 장비 클래스를 포함하게될경우

클래스내의 클래스를 설계할때에는 두가지 경우를 생각해야한다.
1. Is-A (Knight is-A Player? = 기사는 플레이어다) OK->상속관계
2. Has-A (Knight Has-A Inventory? = 기사는 인벤토리를 갖고(포함)있다) OK->포함관계

포함관계일 경우, 클래스의 멤버변수로 클래스를 들고있게 된다. 이경우, 나이트가 만들어짐과 동시에 인벤토리가 선처리 영역에서 같이 생성된다.
그렇기에 생성자내에서 인벤토리를 초기화하게 되면, ex) class Knightr{ Knight() { public: _inventory = Inventory(20); //여긴 생성자 } public: Inventory _inventory; //여긴 멤버변수}
멤버변수 선언에서 하나의 기본생성자를 사용하는 인벤토리가 생성되고, 초기화단계에서 인자20을 받는 새로운 인벤토리를 만들어 멤버변수의 인벤토리에 덮어씌우게 되는것이다.
=>즉, 2번의 생성과 2번의소멸(1개는 덮어씌우는순간 기존에 있던 inv의 소멸, 2개째는 나이트가 사라질때 20inv의 소멸)이 나타날것.

그래서 두번의 과정을 거치지않게, 만드는순간에 초기화를 해줘 한번의 과정만을 거치게 해야함. <=즉, 성능이슈 때문
그리고 정의함과 동시에 초기화가 필요한 경우에도 사용함. Const나 참조타입같은 경우.

!즉, 멤버변수에서 만들고, 생성자에서 변수를 변경(복붙)시키려고 새로운 변수를 만드는과정에서 생성과 소멸이 2번 이루어지는걸 막기위해 초기화리스트를 사용한다.
!!솔직히 번거롭다. 그래서 c+11문법, 그냥 멤버변수 선언때 초기화 해주는 방법도 있다. 이게 좋긴한데 틀들은 안쓸수 있어서 위방법을 알아두라는것

[ 연산자 오버로딩 ] 클래스끼리의 연산이 가능하게
int + int 를 하는것처럼, 새로운 버전의 연산자를 만들어서 원하는 타입끼리 연산이 가능하게 하는것.(클래스간의 덧셈 ex.두 클래스내의 posX의 합산 같은것에 쓸수있다.)
연산자와 연산자 오버로딩(함수)의 차이를 꼽자면, 연산자는 피연산자의 개수와 타입이 고정되어있다.
연산자 오버로딩의 경우 일단 연산자 함수를 정의해야한다.
함수에도 멤버함수, 전역함수가 있는것처럼 연산자 함수도 두가지 방식이 있다.
<멤버함수>
retType operator+ (ARG_LIST) { 기능구현 } // ex) Position operator+ (const Position& arg) {기능}
이경우 position pos3 = pos + pos2; 와 pos3 = pos.operator+(pos2); 가 같은 의미가 된다.

a op b 의 경우 a가 피연산자가 되며, a가 클래스여야지만 가능 // pos+1은되지만 1+pos는 안됨.

<전역함수>
a op b에서 a,b모두를 함수의 피연산자로 만들어준다.
Position operator+(int a, const Position& b) {} ; 

[ 객체지향 마무리 ]
1) struct와 class의 차이 : c++에서는 거의 똑같다.
sturct는 기본 접근지정자가 public이고 class는 private라는 정도만 다르다.(사실 이것도 손수 지정해주면 똑같다.)
->struct는 구조체(데이터묶음)로, class는 객체지향 프로그래밍의 특징 용도로 사용하는게 c에서 쓰던문법

2) static변수와 static함수 : 특정개체에 묶인것이 아닌, 클래스(설계도) 자체에 종속됨
static변수의 사용예시 : 스타에서 마린의 공격력 업글은 할때, 새로나온애들은 클래스(설계도)를 수정해서 새롭게 찍어낸다해도 기존에 있던애들은 하나하나 찾아서 공격력을 바꿔주면 번거로울것이다.
=>그래서 모든 객체들이 공유하는 static변수를 만들어(이경우 공격) 관리하면 편하다.
static함수 : static 특성상, 특정 개체와 연관성이 없기에, 멤버변수를 건들수없고, static변수만을 건드릴수있다.
//static = 정적임 = 스택이 아니라 데이터영역에 올라감 = 스택의 데이터가 사라져도 메모리에 남는다는것.

