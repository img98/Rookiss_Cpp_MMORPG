[ 함수 포인터 #1 ]
int*같이 포인터를 선언하기 위해서는 우선 int라는 타입이 필요하듯이,함수포인터를 선언하기 위해선 typedef를 통해 함수를 타입으로 만들어줘야 한다.
ex)typedef int NUMBER; //지금껏 이런 형태로 typedef를 사용해왔다.
사용법: typedef int(FUNC)(int a)
int a를 인풋으로 받고 int타입의 결과를 반환하는 FUNC라는 함수 타입을 정의하였고, 이를 이용하면 int* a; 처럼
FUNC* fn = ADD; // fn이라는 함수포인터를 담는 바구니를 생성할 수 있다.

! 함수포인터를 이용하면 함수를 작동시키라는 명령을 손쉽게 넘길수 있다. //A함수의 인자로 B함수포인터를 넘겨, A에서 B를 이용하라고 쉽게 전달가능

[ 함수 포인터 #2 ]
#1처럼 포인터 바구니를 만들기 위해 2개의 단계를 거칠필요 없이,
ex) int(*fn)(int, int) //이런식으로 한줄로 정의와 바구니 생성을 한번에 진행할 수도 있다. 실제로 이게 많이 사용된다.

그러나 위에서 나온 문법들로는 <전역함수, 정적함수> 만을 담을 수 있다. 그렇게 되면, 클래스에서 주로 사용하는 멤버함수는 담을 수 없다.
이를 해결하기 위해 다음 문법을 사용하면 된다.
typedef int(Knight::*GetHP)(int) //즉, 타입이 되는 함수에 Knight::를 추가해줬다.
GetHP fn = &Knight::GetHP;

[ 함수객체 ]
말그대로 함수처럼 동작하는 객체(class)

함수포인터는 동작(함수)를 넘겨줄때 유용하다.
하지만 1.시그니처가 안맞으면 사용할 수 없고, 2.상태(ex. Knight.hp)를 가질 수 없다.
이를 해결하기 위해 하나의 객체(클래스)를 만들어 이것을 함수처럼 사용하는 것이다.
말그대로 객체 속성이 있기에, 1.여러 시그니처를 넣을 수 있고(함수 오버로딩처럼) 2.상태를 가질수도 있다. 덤으로 생긴것 또한 익숙하다.

클래스내에 operator()()를 통해서 여러 시그니처를 만들 수 있다.
