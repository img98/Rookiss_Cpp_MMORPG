[ 함수 포인터 #1 ]
int*같이 포인터를 선언하기 위해서는 우선 int라는 타입이 필요하듯이,함수포인터를 선언하기 위해선 typedef를 통해 함수를 타입으로 만들어줘야 한다.
ex)typedef int NUMBER; //지금껏 이런 형태로 typedef를 사용해왔다.
사용법: typedef int(FUNC)(int a)
int a를 인풋으로 받고 int타입의 결과를 반환하는 FUNC라는 함수 타입을 정의하였고, 이를 이용하면 int* a; 처럼
FUNC* fn = ADD; // fn이라는 함수포인터를 담는 바구니를 생성할 수 있다.

! 함수포인터를 이용하면 함수를 작동시키라는 명령을 손쉽게 넘길수 있다. //A함수의 인자로 B함수포인터를 넘겨, A에서 B를 이용하라고 쉽게 전달가능

[ 함수 포인터 #2 ]
#1처럼 포인터 바구니를 만들기 위해 2개의 단계를 거칠필요 없이,
ex) int(*fn)(int, int) //이런식으로 한줄로 정의와 바구니 생성을 한번에 진행할 수도 있다. 실제로 이게 많이 사용된다.

그러나 위에서 나온 문법들로는 <전역함수, 정적함수> 만을 담을 수 있다. 그렇게 되면, 클래스에서 주로 사용하는 멤버함수는 담을 수 없다.
이를 해결하기 위해 다음 문법을 사용하면 된다.
typedef int(Knight::*GetHP)(int) //즉, 타입이 되는 함수에 Knight::를 추가해줬다.
GetHP fn = &Knight::GetHP;

[ 함수객체 ]
말그대로 함수처럼 동작하는 객체(class)

함수포인터는 동작(함수)를 넘겨줄때 유용하다.
하지만 1.시그니처가 안맞으면 사용할 수 없고, 2.상태(ex. Knight.hp)를 가질 수 없다.
이를 해결하기 위해 하나의 객체(클래스)를 만들어 이것을 함수처럼 사용하는 것이다.
말그대로 객체 속성이 있기에, 1.여러 시그니처를 넣을 수 있고(함수 오버로딩처럼) 2.상태를 가질수도 있다. 덤으로 생긴것 또한 익숙하다.

클래스내에 operator()()를 통해서 여러 시그니처를 만들 수 있다.

[ 템플릿 기초 #1 ]
템플릿 : 함수나 클래스를 찍어내는 틀
1.함수 템플릿 과 2.클래스 템플릿이 있다.

1.함수 템플릿
template<typename T>
void Print(T a)
여기서 T는 들어오는 인자타입에 따라 변하는 '조커카드' 같은 존재다.
void Print<int>(50.0f) //이런식으로 꺽쇠를 넣어주면 인자를 해당 타입으로만 알아듣게 설정할 수 있다.
조커인 T를 이용하면 인자 외에도
T Add(T a, T b) //이런식으로 아웃풋도 컴파일러가 알아서 인식해서 뱉어낼 수 있다.

만약 각각 다른 타입의 T를 원한다면
template<typename T1, typename T2> 로 사용하면 된다.

[ 템플릿 기초 #2 ]
2.클래스 템플릿
함수에 들어가는 인자가 무엇인지, 인자를 <>를 통해 표시하면 클래스 템플릿을 사용할 수 있다.

경우에 따라
template<typename T, int SIZE>
이런식으로 조커값이 아닌 정해진 값이 필요할 때도 사용할 수 있다.

즉, 템플릿 꺽쇠 안에 들어가는 건 꼭 타입이 아니라, '골라줘야 하는 목록'이라고 볼 수 있다.

[ 콜백 함수 ]
어떤 상황이 일어나면, 이 기능을 호출해줘 라는 기능
함수의 인자로 템플릿을 물려서, 해당 함수에서 필요한 함수를 호출하게 한다. //후에 람다로 더욱 간편하게 구현 가능하다.

