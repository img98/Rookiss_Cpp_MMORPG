[ Vector #1 ]
STL : C++프로그래밍을 할때 필요한 자료구조/알고리즘을 템플릿으로 제공하는 라이브러리
컨테이너(Container): 데이터를 저장하는 객체 (자료구조 Data Structure)
오늘 알아볼 첫번째 컨테이너가 Vector이다.

Vector(동적 배열)
-동작원리 (size/capacity)
-중간 삽입/삭제
-처음/끝 삽입/삭제
-임의 접근

1.동적배열 : 사전에 정한 구조를 변경할 수 없다는 배열의 한계를 극복함 ex) 배열의 크기
동적배열 vector의 사용법>
#include <vector>
vector<int> v;
v.push_back(1);
cout << v[0];

2.동작 원리
1) (여유를 두고) 메모리를 할당한다.
2) 여유분까지 꽉 찼다면, 메모리를 증설한다.

Q1.얼마나 여유분을 잡아야 할까?
A1.
A2와 연결되는 질문. 가기전에 몇개 용어를 알고가자.
size = 실제 사용 데이터 개수
capacity = 여유분을 표함한 데이터 용량

Q2.증설은 얼마나 해야할까?
A2.
컴파일러에 따라 다르다. 1.5배씩 혹은 2배씩 용량을 늘리거나 한다.
//낭비되는 용량이 적게 capacity를 적게할지, 기존데이터 복사횟수를 줄이기위해 capacity를 늘릴지 사이의 딜레마가 존재한다.

Q3.기존데이터를 어떻게 처리할까? 증설된 메모리의 위치는 어디로 해야할까?
A3.
기존의 데이터를 복사해서 위치를 옮겨 새롭게 증설된 메모리에 붙여넣는다.
//이런 복사를 줄이기위해, 처음부터 capacity를 늘려서 만들어두는 v.reserve도 존재한다. (면접에 나올만한 질문)

[ Vector #2 ]
반복자(Iterator) : 컨테이너의 원소(데이터)를 가리키고, 다음/이전 원소로 이동가능. 포인터와 유사!

사용예시> 포인터와 비교하며 알아보자.
vector<int>::iterator it; //it는 그냥 붙인 이름.
int* ptr;

it = v.begin();
ptr = &v[0];

cout << (*it); //실질적으로 포인터는 아니지만, iterator내부에 해당 operator를 지원해서 마치 포인터처럼 쓸수있더라.
cout << (*ptr);

//내부 구조를 살펴보면, iterator에는 포인터도 포함해서, 어떤 컨테이너를 사용하는지 같은 추가정보가 더 들어있다.

컨테이너는 배열형태가 아닌 경우가 많기에,
for(vector<int>::iterator it=v.begin(); it!=v.end(); ++it) {}
//이런식으로 데이터를 넣는게 일반적이다. 후에는 auto를 사용해 좀더 편하게 코딩가능
//참고로 v.end는 v의 마지막 데이터를 뱉는게 아니라, 데이터가 끝났다는 유효범위 끝의 위치를 뱉는거다. ex) v[10]배열의 v[10]자리 반환(v[9]가 아니라)

[ Vector #3 ]
-처음/중간/끝 삽입/삭제
vector = 동적 배열 = 원소가 하나의 메모리 블록에 연속하게 저장된다.
그렇기에 중간에 데이터를 삽입/삭제하기 위해서는, 그 뒤의 데이터들을 하나씩 복사해서 뒤로 한칸씩 밀어야한다. =비효율

처음/중간에 데이터를 삽입 삭제하는것은 비효율적이라는 것을 알 수 있다. 
맨뒤만 사용하면 되는 끝 삽입/삭제가 효율적 (그래서 push_front는 없고 push_back만 있는듯)

-임의 접근(Random Access)
원하는 데이터가 어디있는지 일일이 찾는게 아니라, 한번에 n번째 데이터로 이동 가능

꼭 중간에 삽입하고 싶다면? v.insert를 사용해라. 

위험한 패턴> 만약 배열 중 3이라는 값들을 제거하고 싶다면,
for(vector<int>:: iterator it=v.begin(); it!= v.end();)
{
	int data = *it;
	if(data==3)
	{
		it = v.erase(it);
		//그냥 erase로 지워주기만 하면, 아예 it가 v와 상관없게 되버리기에 ++it를 사용할 수 없다.
		//그렇기에 지운값의 위치를 반환한다는 erase의 특성을 사용해 위치를 it에 다시 담아줘야 한다.
	}
	else
	{
		++it;
	}
}