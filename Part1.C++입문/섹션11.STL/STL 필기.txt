[ Vector #1 ]
STL : C++프로그래밍을 할때 필요한 자료구조/알고리즘을 템플릿으로 제공하는 라이브러리
컨테이너(Container): 데이터를 저장하는 객체 (자료구조 Data Structure)
오늘 알아볼 첫번째 컨테이너가 Vector이다.

Vector(동적 배열)
-동작원리 (size/capacity)
-중간 삽입/삭제
-처음/끝 삽입/삭제
-임의 접근

1.동적배열 : 사전에 정한 구조를 변경할 수 없다는 배열의 한계를 극복함 ex) 배열의 크기
동적배열 vector의 사용법>
#include <vector>
vector<int> v;
v.push_back(1);
cout << v[0];

2.동작 원리
1) (여유를 두고) 메모리를 할당한다.
2) 여유분까지 꽉 찼다면, 메모리를 증설한다.

Q1.얼마나 여유분을 잡아야 할까?
A1.
A2와 연결되는 질문. 가기전에 몇개 용어를 알고가자.
size = 실제 사용 데이터 개수
capacity = 여유분을 표함한 데이터 용량

Q2.증설은 얼마나 해야할까?
A2.
컴파일러에 따라 다르다. 1.5배씩 혹은 2배씩 용량을 늘리거나 한다.
//낭비되는 용량이 적게 capacity를 적게할지, 기존데이터 복사횟수를 줄이기위해 capacity를 늘릴지 사이의 딜레마가 존재한다.

Q3.기존데이터를 어떻게 처리할까? 증설된 메모리의 위치는 어디로 해야할까?
A3.
기존의 데이터를 복사해서 위치를 옮겨 새롭게 증설된 메모리에 붙여넣는다.
//이런 복사를 줄이기위해, 처음부터 capacity를 늘려서 만들어두는 v.reserve도 존재한다. (면접에 나올만한 질문)

[ Vector #2 ]
반복자(Iterator) : 컨테이너의 원소(데이터)를 가리키고, 다음/이전 원소로 이동가능. 포인터와 유사!

사용예시> 포인터와 비교하며 알아보자.
vector<int>::iterator it; //it는 그냥 붙인 이름.
int* ptr;

it = v.begin();
ptr = &v[0];

cout << (*it); //실질적으로 포인터는 아니지만, iterator내부에 해당 operator를 지원해서 마치 포인터처럼 쓸수있더라.
cout << (*ptr);

//내부 구조를 살펴보면, iterator에는 포인터도 포함해서, 어떤 컨테이너를 사용하는지 같은 추가정보가 더 들어있다.

컨테이너는 배열형태가 아닌 경우가 많기에,
for(vector<int>::iterator it=v.begin(); it!=v.end(); ++it) {}
//이런식으로 데이터를 넣는게 일반적이다. 후에는 auto를 사용해 좀더 편하게 코딩가능
//참고로 v.end는 v의 마지막 데이터를 뱉는게 아니라, 데이터가 끝났다는 유효범위 끝의 위치를 뱉는거다. ex) v[10]배열의 v[10]자리 반환(v[9]가 아니라)

[ Vector #3 ]
-처음/중간/끝 삽입/삭제
vector = 동적 배열 = 원소가 하나의 메모리 블록에 연속하게 저장된다.
그렇기에 중간에 데이터를 삽입/삭제하기 위해서는, 그 뒤의 데이터들을 하나씩 복사해서 뒤로 한칸씩 밀어야한다. =비효율

처음/중간에 데이터를 삽입 삭제하는것은 비효율적이라는 것을 알 수 있다. 
맨뒤만 사용하면 되는 끝 삽입/삭제가 효율적 (그래서 push_front는 없고 push_back만 있는듯)

-임의 접근(Random Access)
원하는 데이터가 어디있는지 일일이 찾는게 아니라, 한번에 n번째 데이터로 이동 가능

꼭 중간에 삽입하고 싶다면? v.insert를 사용해라. 

위험한 패턴> 만약 배열 중 3이라는 값들을 제거하고 싶다면,
for(vector<int>:: iterator it=v.begin(); it!= v.end();)
{
	int data = *it;
	if(data==3)
	{
		it = v.erase(it);
		//그냥 erase로 지워주기만 하면, 아예 it가 v와 상관없게 되버리기에 ++it를 사용할 수 없다.
		//그렇기에 지운값의 위치를 반환한다는 erase의 특성을 사용해 위치를 it에 다시 담아줘야 한다.
	}
	else
	{
		++it;
	}
}

[ Vector #4 ]
vector와 Iterator 손수 만들어보기

[ List #1 ]
vector와 사용처가 비슷하기에 생각보다 많이 사용되지 않음.
list는 vector와 달리 '노드방식'으로 구성되어 있다.

list(연결 리스트)
-동작 원리
-중간 삽입/삭제
-처음 끝 삽입/삭제
-임의 접근

#include <list>
list<int> li;

//노드 구조이기에 push_back뿐만 아니라, push_front도 지원한다.
//또한 노드이니 capacity가 없다.

동작 원리>
연결 리스트: 다음 노드의 위치(포인터)를 알고있는 노드의 연결로 이루어진 구조. //학교에서 한 링크드 리스트 개념
class Node
{
public:
	Node* _next;
	int _data;
};

[ List #2 ]
리스트는 노드 구조니까 중간에 새로운 데이터를 삽입/삭제하기 쉽다.
임의접근 같은 경우는? 다음 노드에 도달해야 그다음 노드의 위치를 알 수 있기 때문에, 벡터에 비해 접근에는 어려움이 있다.
또한 여러 노드를 넘어가고 싶다해서 it+10; 이런식으로 이동할 수 없다. 리스트에서는 해당 행위가 굉장히 비효율적이기에, 라이브러리에서 지원하지 않는다.
정 원하면 for문으로 ++10번 돌려야된다.

그런데, 임의접근이 어려운데 중간삽입은 쉽다는게 모순 아닌가? (중간을 찾기까지 임의접근이 필요하니까)
=> 맞다. 삽입/삭제라는 '행위'가 쉬운거지, 거기까지 접근하는건 비효율적이다.
만약 접근위치를 따로 저장해놨다면 효율적으로 쓸수있다.

[ List #3 ]
리스트 구현, 원리는 알고있으니 생략했다.

[ deque ] 데크
dequeue가 아니다.
시퀀스 컨테이너(Sequence Container): 데이터가 삽입 순서대로 나열되는 형태 (vector, list, deque)
1.vector-동적배열 : [         ]
2.list-이중연결리스트 : []<->[]<->[]
3.deque-double ended queue(벡터와 리스트의 중간형태) : [        ]<->[      ]
(배열로 구성되어 있지만, 용량부족으로 배열을 만들때 vector처럼 기존배열을 복사하지않고, 새로운 배열을 만들어 리스트처럼 연결시킨다.)
!단, capacity는 존재하지 않는다. 필요할때마다 배열을 만들면 되기때문이다.

#include <deque>
deque<int> dq;
dq.push_back(1);
dq.push_front(2);
cout<<dq[0]<<endl; //output=2

vector와 마찬가지로 배열 기반으로 동작하지만, 메모리 할당 정책이 다르다.

-동작원리
-중간 삽입/삭제 (Bad, 벡터처럼 중간에 데이터가 들어오면 다른 데이터를 한칸씩 이동시켜야함)
-처음/끝 삽입/삭제 (Good / Good)
-임의 접근 (Good) 
//임의 접근이 좋다는 것은, 데이터간의 밀집이 잘되어있다는 뜻으로, 필연적으로 중간삽입/삭제와 반비례하다.
//그런데 초기 배열의 크기가 어떻게 됨? 4바이트인가?

!결국, 쓰임새는 vector와 비슷하지만, 앞에서 삽입/삭제 하는것이 더 수월하다.