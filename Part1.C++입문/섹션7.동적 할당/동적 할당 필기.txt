[ 동적 할당 ]
-전역(global)/정적(static) 변수 -> 데이터 영역
-지역/매개 변수 -> 스택 영역 : 함수가 끝나면 같이 정리되는 불안정한 메모리
-동적 할당 -> 힙 영역 : 필요할때만 사용할 수 있고(스택처럼), 하지만 스택과 달리 생성/소멸 시점을 우리가 관리할 수 있다.

프로그램이 작동할때는: 유저영역의 프로그램이 os에따른API를 호출해서 커널에게 메모리를 할당해달라고 요청한다. 그러면 커널영역에서 메모리 확인후, 영역을 할당해주고, 유저 프로그램이 이를 사용한다.
그러나 커널은 매우 많은 연산을하기에, 짜잘한것마다 유저와 커널의 소통을 시켜줄수는 없음.
=>그래서 처음 할당해줄때 메모리를 큼직하게 할당해주고, 프로그램이 알아서 그걸 짤라서 쓰는것. ->이것이 힙영역인듯?

c++에서는 기본적으로 CRT(C런타임 라이브러리)의 힙관리자를 통해 힙 영역을 사용한다. 단, 정말 원한다면 직접 API를 호출해 힙을 생성하고 관리할 수도 있다.
아래가 CRT의 힙관리자 명령어들이다.
<동적할당과 연관된 함수/연산자> : malloc/ free, new/delete, new[]/delete[]
1. malloc() = 얼마만큼 메모리를 할당해줘=>커널에서 할당받은 큰 힙 영역중, 얼마만큼 짤라서 그 시작주소를 리턴
void* pointer = malloc(1000); 이게 기본적인 동적할당 양식
//보이드 포인터가 멀까?= 포인터(주소)는 맞는데, 타고가면 뭐가있는지(type=void) 모르겠으니 너가 적당히 변환해서 사용해라. ( 아직 어떤 용도로 쓸지 정하지 않았으니 void를 쓰는듯 )
Knight* k1 = (Knight*)pointer; 이런식으로 캐스팅을 통해, 시작주소의 타입을 바꿔 나이트의 메모리를 할당해줄수있겠다.
//그런데 나이트의 용량이 1000바이트가 안될텐데, 너무 많이 할당했다. => void* pointer = malloc(sizeof(Knight)); 이런식으로 크기에 맞게 할당도 가능

1-2.free() = 할당된 영역을 해제, malloc과 짝꿍으로 나옴.
free(pointer); 이렇게 메모리해제. 이게 힙영역의 가장 큰 특징. 데이터할당의 생성삭제를 내가 조절가능
CRT가 알아서 할당된 메모리크기를 저장하는 기능이 있어서(예를들면 헤더 추가라거나), 해제할때는 메모리크기 신경안써도 된다.

2.new / delete : c++에서 추가됨. malloc/free는 함수고 new/delete는 연산자다.
Knight* k2 = new Knight; //type* name = new type; 타입을 알려주면 자동으로 할당크기와 주소를 뱉는다. => 쓰기 더편함
delete k2;
아래나올 new/delete와 거의 비슷하기에 한꺼번에 설명하겠다.

3. new[] / delete[] : new가 malloc에비해 좋긴한데, 배열같이 N개 데이터를 할당하려면 불편함(코드 여러번쳐야됨)
Knight* k3 = new Knight[5]; //배열문법처럼, new를 5번해서, 5개의 Knight메모리를 할당해 이어준것.
Knight* k4 = k3+1; 이런식으로 나이트 추가가능
delete[] k3;
//사실 new[]는 잘안씀

=>결과적으로, new/delete가 쓰기편함. 그런데 타입에 상관없이 일정크기 메모리를 할당받으려면 malloc을 써야됨.
==>근본적인 차이는 new/delete는 타입이 클래스인경우 생성자/소멸자를 호출해준다! 이게중요

<동적할당에서 나올만한 버그> :
힙오버플로우
DoubleFree:프리 여러번함 //이게 생각보다 많이나온다.
Use-After-Free:free가 할당구역을 없앤(반납한)것 뿐이기에, 위의 k1처럼 주소를 따놓으면 거기다가 데이터를 보낼수있기에, 크래시가 안나고 데이터오염이 됨.

[ 타입 변환 #1,2 ] = 캐스팅
<타입변환 유형> (비트열 재구성 여부)
1. 값 타입 변환
특징) 의미를 유지하기 위해, 원본 객체와 다른 비트열을 재구성 
int b; float a = (float) b;
2. 참조 타입 변환 //거의 안쓰는데, 포인터 타입변환도 참조탙입변화랑 비슷해서 겸사겸사 배워두자.
특징) 비트열 재구성을 하지 않기에, 데이터에 대한 '관점'만 바뀐것
int b; float a = (float&) b;

-안전도 분류
1. 안전한 변환
특징) 의미가 항상 100% 완전히 일치

ex) 작은 바구니에서 큰 바구니로 이동(업캐스트) // int b=10; __int64 a=b; 이럴때 문제없음
2. 불안전한 변환
특징) 의미의 100%변환을 보장하지 못하는 경우
ex) 타입이 다르거나, 같은 타입이지만 큰바구니에서 작은바구니로 이동(다운캐스팅)

-프로그래머 의도에 따른 분류
1. 암시적 변환
특징) 이미 알려진 타입 변환 규치엑 따라, 컴파일러가 자동으로 타입변환
int a-10; float b= a; 하면 알아서 컴파일러가 (float)변환해줌
2. 명시적 변환

-아무런 연관이 없는 클래스간의 변환은 어떻게 이루어지나?
1. 연관없는 클래스 사이의 '값 타입' 변환
특징) 일반적으론 안됨. //타입변환 생성자로 어떻게 꼬아서만들면 되긴한다. 근데 왜 그러겠나.
2.연관없는 클래스간 '참조 타입' 변환
특징) 명시적으로 하면 변환 되더라.

-상속관계에 있는 클래스 간의 변환
1. 상속 관계 클래스의 '값 타입' 변환
부모 클래스에 자식 클래스를 넣는건 가능(반대는 불가) //부모에 있는 속성들을 자식은 전부 갖고있으니, 새로 만들때 구조상으로 문제없다 생각하면 되겠다.
2. 상속 관계 클래스의 '참조 타입' 변환
위처럼, 부모에 자식을 대입하는건 가능, 그러나 반대는 불가(명시적으로 타입변환해주면 되기는 한다.)

결론>
값 타입 변환 : 진짜 비트열도 바꾸고, 논리적으로 말이 되게 바꾸는 변환. ex) Bulldog->dog (Ok) Dog->Knight (No)
참조 타입 변환 : 비트열의 변화 없이, 우리의 '관점'만 바꾸는 변환. 명시적으로 요구하면 변환해주긴 하는데, 암시적으로 하면 안전성 여부의 연관해서 해줌.

[ 타입 변환 #3 ]
사실 참조타입 변환은 잘안씀
이제나올 포인터 타입 변환이 가장 중요

3강은 복습파트 : 함수의 인자로 포인터를 넘겨주것과, 일반타입?을 보내주는것의 차이. 일반타입을 보내면 그값을 복사해서 함수에서 사용하게됨.
그렇기에 그값의 크기가 크다면 메모리 부하가 걸릴수도있음

[ 타입 변환 #4 ] 타입변환(포인터)
1. 연관성이 전혀없는 클래스간의 포인터 변환을 어떻게할까?
참조변환과 비슷하다. ex) Item* item = knight;
딱봐도 이상하기에 암시적으로는 컴파일러가 에러로 받아들인다. 하지만 명시적으로 타입변환 처리를 해준다면 사용이 가능해진다. <-이게 c++의 무서움

그런데 위와같이 타입변환으로 처리를 한다면 문제가 발생할 수 있다.
우리가 자주 얘기하던, 클래스의 끝부분을 표시하는 값을 다른 값으로 덮어씌워서(item과 knight의 사이즈 차이로인해 발생) 이상한 값이 나오거나 다른 데이터를 오염시킬수도 있다.
=> 이게 바로 터지면 그나마 다행인데, 안터지고 오염이 엄청 진행된 후에 발견되면 야단남.

2. 연관이 있는 클래스 간의 포인터 변환
2-1. 부모->자식 (Item->Weapon) Weapon* weapon = item;의 경우
암시적으로는 변환 불가능.
상식적으로 item은 weapon이 아닐수도 있기에, 위와 같은 방식은 사용하면 에러가 나온다.(위험)
상세설명= 웨폰은 아이템보다 더 큰 범주를 의미한다. 그야 item에 살을 붙여서 만든게 weapon이니까. 그런데 item을 weapon에 넣으려하면,
weapon에 추가되어야 할 살들에 대한 정보가 없다. 그렇기에 불가능하다.
//또한 추가로, item의 메모리 영역이 weapon보다 작다(위와 같은말). 그렇기에, 예를들어 weapon의 damage라는 영역을 건드리려 한다면,
///item의 메모리 영역을 넘어서는 부위에 접근하려하는것이기에 에러가 난다.

2-2. 자식->부모 (Weapon->Item) Item* item = weapon;
= 안전하게 변환가능
그야 모든 weapon은 item이니까.
item이 weapon보다 적은 메모리 영역을 필요로 하기에, weapon의 데이터를 item으로 관측할 수 있다.
//그런데 의문이, weapon에 붙은 '살' 데이터들은 그저 버려지는건가? 이거에 대한 설명은 없더라. (거기까지는 안읽는다고 보면될듯? 데이터차지는 그대로이고)

결론 : 명시적으로 타입변환할때는 항상 조심해야함.
그러면 계속 암시적으로도 ok나오는 코드만 짜면 되는거 아닌가? => 아니다.
왜? => #5 로

[ 타입 변환 #5 ]
다음의 예시를 생각해보자. inventory라는 item배열에 item의 자식인weapon과 armor라는 클래스를 넣는경우다.
inventory에 들어간 weapon을 다시 weapon으로써 사용하기 위해,
Weapon* weapon = (Weapon*)inventory[i]; 를 사용하면 우리는 이것이 weapon이라고 확신할수 있기에 사용할수있지만,
item타입을 weapon타입으로 변한시킨, 즉 부모클래스를 자식클래스로 변환시킨 것이기에 위험하지만 필요한 케이스라고 볼 수 있다.
=> 이렇게 부모 자식사이를 왔다갔다 해야하는 경우가 많기에, 무조건 암시적으로 용인되는 코드만 사용할 수 없다는 것이다.

<!!중요!!>
최초에 weapon으로 만들었다가 item으로 타입변환을 사용했던 녀석을, item의 소멸자 delete(메모리할당 해제)를 해준다면?
=>item의 소멸자가 호출되기에, item부분만 지워지고 남은 weapon부는 완벽히 지워지지 않을수 있다. => 데이터 누수가 생김!
그렇기에, class내부의 속성중 _itemType을 확인해서, 그 클래스에 맞는 소멸자를 사용해야 안전을 보장할 수 있다.
//여기서 스킬인데, 소멸자에 virtual을 붙여 가상함수로 만들어주면, 각 타입에 맞는 소멸자를 호출하게 만들수있다.

어쨋든 중요한건, 상속관계가 있는 클래스를 만들때에는 꼭 소멸자에 virtual을 사용해야 한다는 것이다.

!결론>
1.포인터vs일반타입의 데이터구조 차이 (Knight a 와 Knight* a 의 차이)
2.포인터 사이의 타입변환(캐스팅)을 할때는 매우매우 조심해야한다!
3.부모-자식 관계에서 부모 클래스의 소멸자에는 까먹지말고 virtual을 붙이자!!!
->(이유: 상속관계에 의해 함수를 재정의할때, 재정의 된 타입에 따라 실행되기에
virtual을 붙여 가상함수 테이블을 만들어지게하여 실제 객체가 어떤 class로 만들어졌는지에 따라 함수를 호출하게 하자.)