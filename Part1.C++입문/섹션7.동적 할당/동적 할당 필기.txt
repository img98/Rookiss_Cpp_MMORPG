[ 동적 할당 ]
-전역(global)/정적(static) 변수 -> 데이터 영역
-지역/매개 변수 -> 스택 영역 : 함수가 끝나면 같이 정리되는 불안정한 메모리
-동적 할당 -> 힙 영역 : 필요할때만 사용할 수 있고(스택처럼), 하지만 스택과 달리 생성/소멸 시점을 우리가 관리할 수 있다.

프로그램이 작동할때는: 유저영역의 프로그램이 os에따른API를 호출해서 커널에게 메모리를 할당해달라고 요청한다. 그러면 커널영역에서 메모리 확인후, 영역을 할당해주고, 유저 프로그램이 이를 사용한다.
그러나 커널은 매우 많은 연산을하기에, 짜잘한것마다 유저와 커널의 소통을 시켜줄수는 없음.
=>그래서 처음 할당해줄때 메모리를 큼직하게 할당해주고, 프로그램이 알아서 그걸 짤라서 쓰는것. ->이것이 힙영역인듯?

c++에서는 기본적으로 CRT(C런타임 라이브러리)의 힙관리자를 통해 힙 영역을 사용한다. 단, 정말 원한다면 직접 API를 호출해 힙을 생성하고 관리할 수도 있다.
아래가 CRT의 힙관리자 명령어들이다.
<동적할당과 연관된 함수/연산자> : malloc/ free, new/delete, new[]/delete[]
1. malloc() = 얼마만큼 메모리를 할당해줘=>커널에서 할당받은 큰 힙 영역중, 얼마만큼 짤라서 그 시작주소를 리턴
void* pointer = malloc(1000); 이게 기본적인 동적할당 양식
//보이드 포인터가 멀까?= 포인터(주소)는 맞는데, 타고가면 뭐가있는지(type=void) 모르겠으니 너가 적당히 변환해서 사용해라. ( 아직 어떤 용도로 쓸지 정하지 않았으니 void를 쓰는듯 )
Knight* k1 = (Knight*)pointer; 이런식으로 캐스팅을 통해, 시작주소의 타입을 바꿔 나이트의 메모리를 할당해줄수있겠다.
//그런데 나이트의 용량이 1000바이트가 안될텐데, 너무 많이 할당했다. => void* pointer = malloc(sizeof(Knight)); 이런식으로 크기에 맞게 할당도 가능

1-2.free() = 할당된 영역을 해제, malloc과 짝꿍으로 나옴.
free(pointer); 이렇게 메모리해제. 이게 힙영역의 가장 큰 특징. 데이터할당의 생성삭제를 내가 조절가능
CRT가 알아서 할당된 메모리크기를 저장하는 기능이 있어서(예를들면 헤더 추가라거나), 해제할때는 메모리크기 신경안써도 된다.

2.new / delete : c++에서 추가됨. malloc/free는 함수고 new/delete는 연산자다.
Knight* k2 = new Knight; //type* name = new type; 타입을 알려주면 자동으로 할당크기와 주소를 뱉는다. => 쓰기 더편함
delete k2;
아래나올 new/delete와 거의 비슷하기에 한꺼번에 설명하겠다.

3. new[] / delete[] : new가 malloc에비해 좋긴한데, 배열같이 N개 데이터를 할당하려면 불편함(코드 여러번쳐야됨)
Knight* k3 = new Knight[5]; //배열문법처럼, new를 5번해서, 5개의 Knight메모리를 할당해 이어준것.
Knight* k4 = k3+1; 이런식으로 나이트 추가가능
delete[] k3;
//사실 new[]는 잘안씀

=>결과적으로, new/delete가 쓰기편함. 그런데 타입에 상관없이 일정크기 메모리를 할당받으려면 malloc을 써야됨.
==>근본적인 차이는 new/delete는 타입이 클래스인경우 생성자/소멸자를 호출해준다! 이게중요

<동적할당에서 나올만한 버그> :
힙오버플로우
DoubleFree:프리 여러번함 //이게 생각보다 많이나온다.
Use-After-Free:free가 할당구역을 없앤(반납한)것 뿐이기에, 위의 k1처럼 주소를 따놓으면 거기다가 데이터를 보낼수있기에, 크래시가 안나고 데이터오염이 됨.

[ 타입 변환 #1,2 ] = 캐스팅
<타입변환 유형> (비트열 재구성 여부)
1. 값 타입 변환
특징) 의미를 유지하기 위해, 원본 객체와 다른 비트열을 재구성 
int b; float a = (float) b;
2. 참조 타입 변환 //거의 안쓰는데, 포인터 타입변환도 참조탙입변화랑 비슷해서 겸사겸사 배워두자.
특징) 비트열 재구성을 하지 않기에, 데이터에 대한 '관점'만 바뀐것
int b; float a = (float&) b;

-안전도 분류
1. 안전한 변환
특징) 의미가 항상 100% 완전히 일치

ex) 작은 바구니에서 큰 바구니로 이동(업캐스트) // int b=10; __int64 a=b; 이럴때 문제없음
2. 불안전한 변환
특징) 의미의 100%변환을 보장하지 못하는 경우
ex) 타입이 다르거나, 같은 타입이지만 큰바구니에서 작은바구니로 이동(다운캐스팅)

-프로그래머 의도에 따른 분류
1. 암시적 변환
특징) 이미 알려진 타입 변환 규치엑 따라, 컴파일러가 자동으로 타입변환
int a-10; float b= a; 하면 알아서 컴파일러가 (float)변환해줌
2. 명시적 변환

-아무런 연관이 없는 클래스간의 변환은 어떻게 이루어지나?
1. 연관없는 클래스 사이의 '값 타입' 변환
특징) 일반적으론 안됨. //타입변환 생성자로 어떻게 꼬아서만들면 되긴한다. 근데 왜 그러겠나.
2.연관없는 클래스간 '참조 타입' 변환
특징) 명시적으로 하면 변환 되더라.

-상속관계에 있는 클래스 간의 변환
1. 상속 관계 클래스의 '값 타입' 변환
부모 클래스에 자식 클래스를 넣는건 가능(반대는 불가) //부모에 있는 속성들을 자식은 전부 갖고있으니, 새로 만들때 구조상으로 문제없다 생각하면 되겠다.
2. 상속 관계 클래스의 '참조 타입' 변환
위처럼, 부모에 자식을 대입하는건 가능, 그러나 반대는 불가(명시적으로 타입변환해주면 되기는 한다.)

결론>
값 타입 변환 : 진짜 비트열도 바꾸고, 논리적으로 말이 되게 바꾸는 변환. ex) Bulldog->dog (Ok) Dog->Knight (No)
참조 타입 변환 : 비트열의 변화 없이, 우리의 '관점'만 바꾸는 변환. 명시적으로 요구하면 변환해주긴 하는데, 암시적으로 하면 안전성 여부의 연관해서 해줌.

[ 타입 변환 #3 ]
사실 참조타입 변환은 잘안씀
이제나올 포인터 타입 변환이 가장 중요

3강은 복습파트 : 함수의 인자로 포인터를 넘겨주것과, 일반타입?을 보내주는것의 차이. 일반타입을 보내면 그값을 복사해서 함수에서 사용하게됨.
그렇기에 그값의 크기가 크다면 메모리 부하가 걸릴수도있음

[ 타입 변환 #4 ] 타입변환(포인터)
1. 연관성이 전혀없는 클래스간의 포인터 변환을 어떻게할까?
참조변환과 비슷하다. ex) Item* item = knight;
딱봐도 이상하기에 암시적으로는 컴파일러가 에러로 받아들인다. 하지만 명시적으로 타입변환 처리를 해준다면 사용이 가능해진다. <-이게 c++의 무서움

그런데 위와같이 타입변환으로 처리를 한다면 문제가 발생할 수 있다.
우리가 자주 얘기하던, 클래스의 끝부분을 표시하는 값을 다른 값으로 덮어씌워서(item과 knight의 사이즈 차이로인해 발생) 이상한 값이 나오거나 다른 데이터를 오염시킬수도 있다.
=> 이게 바로 터지면 그나마 다행인데, 안터지고 오염이 엄청 진행된 후에 발견되면 야단남.

2. 연관이 있는 클래스 간의 포인터 변환
2-1. 부모->자식 (Item->Weapon) Weapon* weapon = item;의 경우
암시적으로는 변환 불가능.
상식적으로 item은 weapon이 아닐수도 있기에, 위와 같은 방식은 사용하면 에러가 나온다.(위험)
상세설명= 웨폰은 아이템보다 더 큰 범주를 의미한다. 그야 item에 살을 붙여서 만든게 weapon이니까. 그런데 item을 weapon에 넣으려하면,
weapon에 추가되어야 할 살들에 대한 정보가 없다. 그렇기에 불가능하다.
//또한 추가로, item의 메모리 영역이 weapon보다 작다(위와 같은말). 그렇기에, 예를들어 weapon의 damage라는 영역을 건드리려 한다면,
///item의 메모리 영역을 넘어서는 부위에 접근하려하는것이기에 에러가 난다.

2-2. 자식->부모 (Weapon->Item) Item* item = weapon;
= 안전하게 변환가능
그야 모든 weapon은 item이니까.
item이 weapon보다 적은 메모리 영역을 필요로 하기에, weapon의 데이터를 item으로 관측할 수 있다.
//그런데 의문이, weapon에 붙은 '살' 데이터들은 그저 버려지는건가? 이거에 대한 설명은 없더라. (거기까지는 안읽는다고 보면될듯? 데이터차지는 그대로이고)

결론 : 명시적으로 타입변환할때는 항상 조심해야함.
그러면 계속 암시적으로도 ok나오는 코드만 짜면 되는거 아닌가? => 아니다.
왜? => #5 로

[ 타입 변환 #5 ]
다음의 예시를 생각해보자. inventory라는 item배열에 item의 자식인weapon과 armor라는 클래스를 넣는경우다.
inventory에 들어간 weapon을 다시 weapon으로써 사용하기 위해,
Weapon* weapon = (Weapon*)inventory[i]; 를 사용하면 우리는 이것이 weapon이라고 확신할수 있기에 사용할수있지만,
item타입을 weapon타입으로 변한시킨, 즉 부모클래스를 자식클래스로 변환시킨 것이기에 위험하지만 필요한 케이스라고 볼 수 있다.
=> 이렇게 부모 자식사이를 왔다갔다 해야하는 경우가 많기에, 무조건 암시적으로 용인되는 코드만 사용할 수 없다는 것이다.

<!!중요!!>
최초에 weapon으로 만들었다가 item으로 타입변환을 사용했던 녀석을, item의 소멸자 delete(메모리할당 해제)를 해준다면?
=>item의 소멸자가 호출되기에, item부분만 지워지고 남은 weapon부는 완벽히 지워지지 않을수 있다. => 데이터 누수가 생김!
그렇기에, class내부의 속성중 _itemType을 확인해서, 그 클래스에 맞는 소멸자를 사용해야 안전을 보장할 수 있다.
//여기서 스킬인데, 소멸자에 virtual을 붙여 가상함수로 만들어주면, 각 타입에 맞는 소멸자를 호출하게 만들수있다.

어쨋든 중요한건, 상속관계가 있는 클래스를 만들때에는 꼭 소멸자에 virtual을 사용해야 한다는 것이다.

!결론>
1.포인터vs일반타입의 데이터구조 차이 (Knight a 와 Knight* a 의 차이)
2.포인터 사이의 타입변환(캐스팅)을 할때는 매우매우 조심해야한다!
3.부모-자식 관계에서 부모 클래스의 소멸자에는 까먹지말고 virtual을 붙이자!!!
->(이유: 상속관계에 의해 함수를 재정의할때, 재정의 된 타입에 따라 실행되기에
virtual을 붙여 가상함수 테이블을 만들어지게하여 실제 객체가 어떤 class로 만들어졌는지에 따라 함수를 호출하게 하자.)

[ 얕은 복사 vs 깊은 복사 #1 ] 중요(사실 메모리관련은 다중요)
<복사생성자>와 <복사대입연산자>는 컴파일러가 '암시적으로' 만들어주기에 사용하기도 좋고 효과적이기도 하다.
=> 좋긴한데, 이걸론 부족할때가 있다.
컴파일러가 암시적으로 맏는 연산자와 생성자는 '메모리의 데이터롤 고대로 복사한다'는 특징이 있다.
->이게 그냥 int면 상관없는데, 참조값이나 포인터가 데이터로 들어가면 복사로는 곤란해질수있다.

ex) Hunter가 pet을 갖고있다는 의미로, Hunter클래스 내부에는 속성으로 pet클래스가 있다해보자.
 만약 pet의 데이터가 너무 크다면 Hunter하나하나가 용량이 너무 커질것이다. 그렇기에 pet의 포인터를 속성으로 들게하면 해결할 수 있다.
 그러나 이제부터 문제인것이, 만약 Hunter2를 만들때, Hunter1을 사용해 복사생성자나 복사대입연산자를 쓴다고 해보자.
 이때, 우리는 복사를 사용했기에 Hunter2.pet에는 Hunter1.pet의 값이 그대로 복사가 될것이다.
 즉, 하나의 pet1을 hunter1도 hunter2도 자기것이라고 우기게 되는것!
 => 이러한 복사의 형태를 '얕은 복사(Shallow Copy)'라고한다. 멤버데이터를 비트열 단위로 똑같이 복사.
  
 그렇다면 '깊은복사'란? Deep Copy
 :멤버데이터가 참조(주소)값이라면, 아예 데이터를 새로 만들어준다.(원본 객체가 참조하는 대상까지 새로 만들어서 복사)
 ->hunter1.pet1처럼 hunter2.pet2도 만들어주겠다.
  포인터는 주소값 바구니이니까, 새로운 객체를 생성해서 그것의 주소값을 넣어줌.
//그래서 어떻게 쓰는데? 
 Hunter (const Hunter& hunter) {_hp=hunter.hp; _pet = new Pet(*hunter._pet);} //_hp는 얕은복사를, _pet은 깊은복사를 한 모습이다.
 Hunter& operator=(const Hunter& hunter) {_hp=hunter.hp; _pet = new Pet(*hunter._pet); return *this;} //위는 복사생성자, 얘는 복사대입연산자의 차이
 
!즉, 포인터 타입인 속성의 내용물을 어떻게 채워넣을것인가(복사or새롭게)가 얕은,깊은 복사의 큰 차이점이라고 볼수있다.
  
[ 얕은 복사 vs 깊은 복사 #2 ]
암시적 복사 생성자와 복사 대입연산자의 step과정
명시적 복사 생성자와 복사 대입연산자의 step과정을 알아보자.

먼저 결론부터>
-암시적 복사생성자
1)부모 클래스의 복사 생성자 호출 //이경우 Hunter의 부모인 Player
2)멤버 클래스의 복사 생성자 호출 //이경우 pet
3)두 경우 모두아니면,(멤버가 기본타입이면) 메모리복사 사용(얕은복사)

-명시적 복사생성자
1)부모 클래스의 기본 생성자 호출 //복사생성자가 아닌 기본생성자가 호출됨. 즉, 생성자내에 상세히 멀 복사해줄지 써넣지 않으면 넘겨주지않게됨.
//그래서 복사생성자로 쓰고싶으면, 명시적으로 만들때 ':부모' 를 추가하여 복사생성자라고 표시해줘야한다.
2)멤버 클래스의 기본 생성자 호출

-암시적 복사대입연산자
1)부모 클래스의 복사 대입연산자 호출
2)멤버 클래스의 복사 대입연산자 호출
3)두 경우 모두아니면,(멤버가 기본타입이면) 메모리복사 사용(얕은복사)

-명시적 복사대입연산자
알아서 해주는게 없음. 싹다 수동으로해야한다.

[ 캐스팅 4총사 ] static / dynamic / const / reinterpret _cast
지금까지쓰던 (int)문법은 예전 C의 잔재임. C++에서는 다음 4가지 캐스팅을 사용해주는게 좋다.

1) static_cast 
타입 원칙에 비춰볼때, 상식적인 캐스팅만 허용해줌. 가장많이씀(90퍼정도로)
ex) int <-> float //float ratio = static_cast<float>(hp)/maxHp;
	Player* -> Knight* (다운캐스팅) //Knight* k = static_cast<Knight*>(p); //위에 그냥 (Knight*)로 캐스팅해준거보다 가시성 좋아졌네

2) dyamic_cast
상속관계에서의 안전한 캐스팅을 지원. RTTI(RunTime Type Information=다형성)를 사용함
//RTTI= virtual을 쓸때, 객체가 원래 어떤 클래스로 만들어진건질 알기위해 vf테이블을 사용한다는 그개념임
Knight* k = dynamic_cast<Knight*>(p); //다형성을 사용하는것이기에, 사용하고싶으면 클래스 내에 virtual함수가 있어야함.(vftable을 쓰는거니까)
중요!!> 잘못된 타입으로 캐스팅하면, nullptr을 반환한다. 잘못됨을 알수있겠다.
그러나 RTTI를 통해 원본을 확인하는 과정이 추가되기에, 당연히 static_cast보다는 느리다. 타입확인이 꼭 필요한 경우에만 사용하는게 좋다.

3) const_cast
const를 붙이거나 떼는 캐스팅을 할때 사용. (잘안쓴다)

4) reinterpret_cast (얘도 잘안씀)
포인터와 전형 관계없는 다른 타입으로 변환할때 사용함. ex)포인트를 정수로서 사용 (의미없는 예시이긴하다)
가장 위험하지만 강력하다. re-interpret = 다시-간주하다.
즉, 비트열의 변환을 생각하지 않고 변환해서 그대로 사용한다는것.
