[ 동적 할당 ]
-전역(global)/정적(static) 변수 -> 데이터 영역
-지역/매개 변수 -> 스택 영역 : 함수가 끝나면 같이 정리되는 불안정한 메모리
-동적 할당 -> 힙 영역 : 필요할때만 사용할 수 있고(스택처럼), 하지만 스택과 달리 생성/소멸 시점을 우리가 관리할 수 있다.

프로그램이 작동할때는: 유저영역의 프로그램이 os에따른API를 호출해서 커널에게 메모리를 할당해달라고 요청한다. 그러면 커널영역에서 메모리 확인후, 영역을 할당해주고, 유저 프로그램이 이를 사용한다.
그러나 커널은 매우 많은 연산을하기에, 짜잘한것마다 유저와 커널의 소통을 시켜줄수는 없음.
=>그래서 처음 할당해줄때 메모리를 큼직하게 할당해주고, 프로그램이 알아서 그걸 짤라서 쓰는것. ->이것이 힙영역인듯?

c++에서는 기본적으로 CRT(C런타임 라이브러리)의 힙관리자를 통해 힙 영역을 사용한다. 단, 정말 원한다면 직접 API를 호출해 힙을 생성하고 관리할 수도 있다.
아래가 CRT의 힙관리자 명령어들이다.
<동적할당과 연관된 함수/연산자> : malloc/ free, new/delete, new[]/delete[]
1. malloc() = 얼마만큼 메모리를 할당해줘=>커널에서 할당받은 큰 힙 영역중, 얼마만큼 짤라서 그 시작주소를 리턴
void* pointer = malloc(1000); 이게 기본적인 동적할당 양식
//보이드 포인터가 멀까?= 포인터(주소)는 맞는데, 타고가면 뭐가있는지(type=void) 모르겠으니 너가 적당히 변환해서 사용해라. ( 아직 어떤 용도로 쓸지 정하지 않았으니 void를 쓰는듯 )
Knight* k1 = (Knight*)pointer; 이런식으로 캐스팅을 통해, 시작주소의 타입을 바꿔 나이트의 메모리를 할당해줄수있겠다.
//그런데 나이트의 용량이 1000바이트가 안될텐데, 너무 많이 할당했다. => void* pointer = malloc(sizeof(Knight)); 이런식으로 크기에 맞게 할당도 가능

1-2.free() = 할당된 영역을 해제, malloc과 짝꿍으로 나옴.
free(pointer); 이렇게 메모리해제. 이게 힙영역의 가장 큰 특징. 데이터할당의 생성삭제를 내가 조절가능
CRT가 알아서 할당된 메모리크기를 저장하는 기능이 있어서(예를들면 헤더 추가라거나), 해제할때는 메모리크기 신경안써도 된다.

2.new / delete : c++에서 추가됨. malloc/free는 함수고 new/delete는 연산자다.
Knight* k2 = new Knight; //type* name = new type; 타입을 알려주면 자동으로 할당크기와 주소를 뱉는다. => 쓰기 더편함
delete k2;
아래나올 new/delete와 거의 비슷하기에 한꺼번에 설명하겠다.

3. new[] / delete[] : new가 malloc에비해 좋긴한데, 배열같이 N개 데이터를 할당하려면 불편함(코드 여러번쳐야됨)
Knight* k3 = new Knight[5]; //배열문법처럼, new를 5번해서, 5개의 Knight메모리를 할당해 이어준것.
Knight* k4 = k3+1; 이런식으로 나이트 추가가능
delete[] k3;
//사실 new[]는 잘안씀

=>결과적으로, new/delete가 쓰기편함. 그런데 타입에 상관없이 일정크기 메모리를 할당받으려면 malloc을 써야됨.
==>근본적인 차이는 new/delete는 타입이 클래스인경우 생성자/소멸자를 호출해준다! 이게중요

<동적할당에서 나올만한 버그> :
힙오버플로우
DoubleFree:프리 여러번함 //이게 생각보다 많이나온다.
Use-After-Free:free가 할당구역을 없앤(반납한)것 뿐이기에, 위의 k1처럼 주소를 따놓으면 거기다가 데이터를 보낼수있기에, 크래시가 안나고 데이터오염이 됨.

