[ 포인터 기초 #1 ] 
왜 필요한가? : A함수에서 B함수를 호출한다고 생각해보자. 그동안 B함수는 함수를 호출할때 준 인자(매개변수) 외에는 A의 지역변수들을 사용할 수 없었다.
그러나 포인터를 사용한다면, 메모리 주소를 통해 직접 접근할 수 있기에, 이것이 가능해진다.
(또한 인자를 담을 공간도 필요없고, return할 것을 임시로 담을 공간도 필요없으니 메모리 절약도 가능)
이것은 전역변수를 선언하면 똑같이 실행할 수 있지만, 전역변수는 메모리의 데이터 영역을 차지하기에, 메모리낭비가 생긴다.
그렇지만 함수내의 지역변수를 포인터로 접근하게 된다면, 그 지역변수는 스택 메모리에 저장되기에, 사용이 끝난후 삭제할 수 있겠다.
<사용법>
Type* 변수이름 ;
ex) int number = 1 ;
int* ptr = &number ; // ptr은 nuber의주소를 저장하는 바구니
*ptr = 2 ; // 'ptr에 담고있는 주소의 내용물'을 2로 바꿔달라
int value = *ptr ; // 이러면 value에는 2 가 담길것이다.

[ 포인터 기초 #2 ]
 그런데 어쩌피 주소값을 담을거면서 왜 Type* 로 '타입'을 붙여줘야될까? //어쩌피 주소니까 4or8바이트 일건데
=> 타입은, 그 주소로 가면 무엇이 있을지 알려주는 거임.
==>예전에 int 97 과 char 97은 다르다고 했듯이, 얘도 내용물을 어떻게 읽어야 하는지를 가르쳐주는것

그런데 포인터의 문제는, 이렇게 해줌에도, 내용물과 타입의 불일치로 인해 생긴다.
원래 메모리 용량보다 큰 용량을 넣어주면, 해당 주소를 넘어서 다른 주소에까지 그 입력이 넘쳐서 영향받음.

[ 포인터 연산 ]
1) 주소 연산자 ( & ) : 해당 변수의 주소를 알린다(더 정확히 말하면, 해당 변수의 타입에 따라, 맞는 포인터를 반환한다.). &number //지난번에한 int* pointer = &number 의 &이 주소연산자 다.
2) 산술 연산자 ( + - ) : 주소값의 연산, TYPE의 크기만큼 이동하라는 의미가 된다. (마치 배열에서 다음 인덱스로 가듯이) // 다음 바구니로 가라고 이해하자.
ex) pointer += 1 ; 을 하면, pointer는 4바이트가 커질것이다. ( int가 4바이트 이기 때문에 )
3) 간접 연산자 ( * ) : 해당 주소의 '내용물'에 접근
4) 간접 멤버 연산자 ( -> ) : '*'과 '.'을 한번에 사용. 즉, Knight라는 구조체의 속성으로 hp있다고 하면, 일반적으로 *(Knight).hp =100; 이런식으로 접근해야 한다.
그런데 * ( ) . 세개나 쓰려니까 귀찮기에 하나로 묶어버린것이다.(귀찮다기보단, 내용이 복잡해질때의 가독성을 위해서일듯)
ex) Knight->hp = 200;

! 산술 연산자가 좀 특이하네. 다음 바구니(인덱스)를 보는 용도로 사용할듯.  그리고 간접멤버 연산자도 가독성 좋아지니 알아두면 좋겠다.

[ 포인터 실습 ]
전에 말했듯, 매개변수로 포인터를 넘겨주면, 메모리 성능을 크게 상승시킬 수 있다. (실습 : CreatePlayer()와 CreateMonster()를 포인터를 사용할지, 아니면 결과물을 return할지)
만약 구조체를 매개체로 넘겨줬다면, 그리고 그 구조체가 엄청 크다면, 이것을 자신의 지역변수 영역에 복사해 클론을 만들어야해서, 많은 메모리 용량이 필요로 할 것이다.
( 조금이라도 메모리 성능을 잡고싶은 우리는 이걸 피해야 한다. )
그러나 매개변수에 포인터를 넘겨주면, 지역변수에 매개변수인 주소값을 담기는 하지만,  클론을 만들필요가 없기에, 메모리 낭비도 없고, 어셈블리로 봐도 과정이 줄어들어
메모리 성능이 상승한다.