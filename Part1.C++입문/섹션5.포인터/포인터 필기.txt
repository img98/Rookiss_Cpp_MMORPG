[ 포인터 기초 #1 ] *
왜 필요한가? : A함수에서 B함수를 호출한다고 생각해보자. 그동안 B함수는 함수를 호출할때 준 인자(매개변수) 외에는 A의 지역변수들을 사용할 수 없었다.
그러나 포인터를 사용한다면, 메모리 주소를 통해 직접 접근할 수 있기에, 이것이 가능해진다.
(또한 인자를 담을 공간도 필요없고, return할 것을 임시로 담을 공간도 필요없으니 메모리 절약도 가능)
이것은 전역변수를 선언하면 똑같이 실행할 수 있지만, 전역변수는 메모리의 데이터 영역을 차지하기에, 메모리낭비가 생긴다.
그렇지만 함수내의 지역변수를 포인터로 접근하게 된다면, 그 지역변수는 스택 메모리에 저장되기에, 사용이 끝난후 삭제할 수 있겠다.
<사용법>
Type* 변수이름 ;
ex) int number = 1 ;
int* ptr = &number ; // ptr은 nuber의주소를 저장하는 바구니
*ptr = 2 ; // 'ptr에 담고있는 주소의 내용물'을 2로 바꿔달라
int value = *ptr ; // 이러면 value에는 2 가 담길것이다.

[ 포인터 기초 #2 ]
 그런데 어쩌피 주소값을 담을거면서 왜 Type* 로 '타입'을 붙여줘야될까? //어쩌피 주소니까 4or8바이트 일건데
=> 타입은, 그 주소로 가면 무엇이 있을지 알려주는 거임.
==>예전에 int 97 과 char 97은 다르다고 했듯이, 얘도 내용물을 어떻게 읽어야 하는지를 가르쳐주는것

그런데 포인터의 문제는, 이렇게 해줌에도, 내용물과 타입의 불일치로 인해 생긴다.
원래 메모리 용량보다 큰 용량을 넣어주면, 해당 주소를 넘어서 다른 주소에까지 그 입력이 넘쳐서 영향받음.

[ 포인터 연산 ]
1) 주소 연산자 ( & ) : 해당 변수의 주소를 알린다(더 정확히 말하면, 해당 변수의 타입에 따라, 맞는 포인터를 반환한다.). &number //지난번에한 int* pointer = &number 의 &이 주소연산자 다.
2) 산술 연산자 ( + - ) : 주소값의 연산, TYPE의 크기만큼 이동하라는 의미가 된다. (마치 배열에서 다음 인덱스로 가듯이) // 다음 바구니로 가라고 이해하자.
ex) pointer += 1 ; 을 하면, pointer는 4바이트가 커질것이다. ( int가 4바이트 이기 때문에 )
3) 간접 연산자 ( * ) : 해당 주소의 '내용물'에 접근
4) 간접 멤버 연산자 ( -> ) : '*'과 '.'을 한번에 사용. 즉, Knight라는 구조체의 속성으로 hp있다고 하면, 일반적으로 *(Knight).hp =100; 이런식으로 접근해야 한다.
그런데 * ( ) . 세개나 쓰려니까 귀찮기에 하나로 묶어버린것이다.(귀찮다기보단, 내용이 복잡해질때의 가독성을 위해서일듯)
ex) Knight->hp = 200;

! 산술 연산자가 좀 특이하네. 다음 바구니(인덱스)를 보는 용도로 사용할듯.  그리고 간접멤버 연산자도 가독성 좋아지니 알아두면 좋겠다.

[ 포인터 실습 ]
전에 말했듯, 매개변수로 포인터를 넘겨주면, 메모리 성능을 크게 상승시킬 수 있다. (실습 : CreatePlayer()와 CreateMonster()를 포인터를 사용할지, 아니면 결과물을 return할지)
만약 구조체를 매개체로 넘겨줬다면, 그리고 그 구조체가 엄청 크다면, 이것을 자신의 지역변수 영역에 복사해 클론을 만들어야해서, 많은 메모리 용량이 필요로 할 것이다.
( 조금이라도 메모리 성능을 잡고싶은 우리는 이걸 피해야 한다. )
그러나 매개변수에 포인터를 넘겨주면, 지역변수에 매개변수인 주소값을 담기는 하지만,  클론을 만들필요가 없기에, 메모리 낭비도 없고, 어셈블리로 봐도 과정이 줄어들어
메모리 성능이 상승한다.

[ 참조 기초 ] &, 포인터와 비슷하다. 
int number = 1 ; int* pointer = &number ; 이런식으로 포인터를 사용했다.
참조문법을 사용하면 int& reference = number; 
어셈블리 관점에서 보면, 작동방식은 int*와 완전히 똑같다. C++관점에서 보면 nuber라는 바구니에 '또다른 이름'을 부여한 것이다.
앞으로 reference에 값을 넣거나 바꾸면, 실제 nuber에서도 그값이 변화한다.

똑같다면 왜 포인터말고 참조를 쓰는가? => 참조 전달때문에
함수에서 Stat->hp 같은, 간접멤버연산을 자주 쓰기 귀찮고 가독성이 안좋아서, Stat.hp 이렇게 값전달처럼 쓰고 싶어서 사용하는 것이다.
이렇게되면, 주소전달처럼 주소를 원본주소를 사용하기에 메모리 절약이 되고, 값전달처럼 쉬운(익숙한) 문법을 사용할 수 있다.
//
구조체를 매개변수로 받는 함수에서, Stat이라는 매개변수가 1000바이트를 넘는 대형 구조체라면
1) 값전달 : Func(Stat a) {} : 1000바이트를 복사한다.
2) 주소 전달: Funf(Stat* a) {} : a의 주소, 즉 8바이트만 복사한다.
3) 참조 전달 : Func(Stat& a) {} : 8바이트주소를 받지만, 매개변수를 넣을때, &a 이런식으로 주소라고 귀찮게 티낼 필요도 없고, 사용도 익숙한 문법이다.

! 참조 : 사용용도는 포인터와 같지만, 사용하는 인터페이스가 다르기때문에 쓴다고 생각하면될듯

[ 포인터 vs 참조 ]
성능적으론 똑같음, (1)편의성은 참조가 좋다 ( -> 대신 . ) 그러나 편의성이 좋다는게 꼭 장점만은 아님.
=> 포인터는 주소를 넘기니, 확실히 원본을 넘긴다는 표시를 낼수있는데, 참조는 자연스럽게 지나칠수 있음. <= FuncPtr(&info), FuncRef(info)
//내용물을 바꿔야 되는 reference의 경우, 알아보기위해 #define OUT을 사용하는 경우가 많다고한다.

앞서 값전달은 메모리 낭비로 안좋다고했다. 그런데 값을 읽기만 할건데, 주소로 갖고왔을때, 실수로 내용물을 변형시킬까봐 걱정이 된다면, const를 사용하면 된다.
ex) 참조 : FuncRef ( const Stat& info )
 포인터는 별 앞이냐, 뒤냐에 따라 const를 붙였을때 의미가 다르다. (주소값을 바꾸느냐, 내용을 바꾸느냐)
1, 별 뒤 : Func ( Stat* const info ) : 주소값을 바꾸지 못함. ex) info = &newAddress ; 이런게 불가능 //즉, info라는 주소값 바구니를 const화 시킨다.
2. 별 앞 : Func( const Stat* info /또는 Stat const* info ) : 내용물을 바꾸지 못한다. ex) info->hp = 100; 이게불가
둘다 막고싶다면? Func ( const Stat* const info )

//포인터는 안붙여도 되긴하지만, 참조는 거의 어지간하면 붙는다.

(2) 초기화 여부 (이게 참조와 포인터의 가장큰 차이)
포인터는 일단 바구니를 만들고, 나중에 바구니의 내용물을 만들어 채워도 되지만, //포인터가 어떤 주소도 가리키고 있지 않다는걸 표현할때는 nullptr사용
참조타입은 바구니의 2번째 이름이니, 참조 대상이 없으면 안된다.
//원본 대상이 100퍼센트 있는지 없는지에 따라, 포인터 참조 선택

Bonus) 포인터로 사용하던걸 참조로, 참조로 쓰던걸 포인터로 넘겨주고 싶으면 어떻게 해야할까?
레퍼런스 인자에 *을(*pointer)를 붙여 내용물을 넘겨주거나, 포인터 인자에 &을(&reference)을 붙여 주소값을 넘겨주면 된다. //결국 주소값이나 내용물을 맞춰서 주면된다는 말

[ 배열 기초 ] []
TYPE 이름[개수];
배열의 이름은 곧 배열의 시작 주소를 가리키는 포인터 이다.
배열은 데이터주소가 연결되어 있다는 걸 이용해, 포인터와 참조를 사용해 해당 주소에 내용물을 채울수 있다. //사실 이건 연습용으로 한거
=>그런데 이게 가독성이 안좋으니 인덱스를 붙여 배열을 이용한다.

배열 초기화 문법
1. int s[5] = {};//이러면 0으로 초기화
2. int s[5] = { 1, 2 } ; // 이러면 0, 1인덱스는 1,2로 차지만 뒤는 0으로 초기화
3. int s[ ] = {1,2}; //이러면 데이터 개수만큼의 크기의 배열을 만들어줌

[ 포인터 vs 배열 ] +문자열
"Hello World" 라는 문자열을 치면, 타입이 const char로 상수화 되더라.
포인터와 배열이 첫주소를 갖고온다는데에서 비슷하다 생각할수 있지만, 전혀다르다.
const char* test1 = "Hello World";
char test2[12] = "Hello World"
위 두 코드의 차이점은, test1의 경우 .data 영역에 있는 Hello World가 시작되는 H의 주소를 담고있다.
test2의 경우 .rdata영역에 있는 Hello World의 문자들을 복사해서 test2라는 배열안에 복사해 넣은것이다.
//즉, 원본에 연결되는 포인터와, 원본을 복사한 배열의 차이인듯

만약 함수를 만들때, 인자로 배열을 받는다면, 배열의 이름은 그 배열의 시작 주소값을 의미하기에,
배열을 전달받은 함수는 주소값을 통해 연산을 하므로, 전달받은 매개변수를 변경시킬수 있다.
//그렇기에 원본의 변형 없이 사용하고 싶으면, 전달받은 주소값을 통해, 내부에서 배열을 한번더 선언하여 스택메모리에 복사해서 사용해야 할 듯.

[ 로또 번호 생성기 ]
. 배열의 count를 쓸순 없더라. 그래서 sizeof(배열) / sizeof(배열타입) 으로 나눗셈을 해주니, 자동으로 배열 개수를 알수 있더라.

[ 다중 포인터 ] ** , 이런 별을 무한대로 늘릴수있음. 물론 거의 2차까지밖에 안씀.
계속 강조하지만 포인터를 쓸때는 type* 을 사용해야 되는데, 이것은 즉, '타입'(type)의 '주소값'(*)을 담는 바구니를 만든것이다.
그렇기에, 함수에 매개변수로 type*을 넘겨주게되면 그 주소값의 내용물로 들어가는 명령문(*.이나->)을 통해 내용물을 고쳤다.
그러나, 이또한 매개변수의 값(포인터)를 복사해와서, 함수의 지역변수에 그 주소값을 복사해서 사용한 것이기에,
주소값을 찾아가는 것은 가능했어도 주소값 자체를 바꿀수는 없다. //사실 return쓰면 되기는 하는데, 그럼 메모리 낭비니까 안씀
(매개변수에 연결된 주소(ex.배열)를 바꿀수가 없다는 말)
그렇다면, 주소값을 바꿀수는 없을까?
=> 그게바로 TYPE**, '타입의 주소값'(type*)의 주소값'(*)을 담는 바구니이다. <= (type*)*
//앞서 숫자데이터(int)를 바꾸고 싶으면 숫자데이터의 포인터(int*)를 썻듯이, 포인터를 바꾸고싶으면 포인터의 포인터(**)를 쓰면 되는것!

[ 다차원 배열 ] [][]
그동안 배열을 [][]이런식으로 여러개 겹쳐, 차원을 늘리듯이 생각했지만, 사실 메모리상으로는 첫번째 배열이 끝나는 주소의 바로뒤에, 그다음 배열의 주소가 나온다.
=> 그렇기에 사실 a[2][5] 는 b[10]과 같은 메모리를 차지한다. (즉, 어셈블리상 a는 2차원이 아니고, 1차원이라고 볼수있다.)
//예전에 다차원배열에서 [a][b] 일때, 1,1 -> 2,1 ->...  이런식으로 세는 것보다, 1,1-> 1,2.. 이런식으로 세는게 더좋은데, 이유는 주소가 가깝기 때문이라 했던게 이해된다.

[ 포인터 마무리 ] 마무리 아님. 주의사항과 팁
1) 포인터 vs 배열 2탄
2) 포인터 사용의 주의사항(마음가짐)

<포인터 vs 배열> //사실 당연한 얘기를 하는거라;
포인터는 주소를 담는다. 즉, 진품은 데이터 저멀리 있고, 거기로 워프하는 전송장치.
배열은 입력을 복사한 진짜 데이터.  데이터의 묶음이기에 무거움
- 배열의 이름이 배열의 시작 주소값을 가리티기에, 포인터와 같다고 착각하는 경우가 많다. (사실 사용법은 비슷한데, 본체 데이터의 유무 차이가 크다)
-- 사실 1차원배열과 포인터는 문법이 완전호환 되기는하다.
-그런데 이게 2차원배열과 다중 포인터로 들어가면 차이가 확연해짐. 둘이 아예 다른 개념이기 때문.
다중 포인터는 말그대로, 포인터를 담는 포인터를 얘기하는것이고, 다차원배열은 그저 1차원배열을 표현하는 방식이기때문임.

<주의사항>
c++의 무서운점. 데이터주소 영역을 잘못지정해줘서 실수를 범할 경우, 프로그램이 바로 뻗는게 아니라 계속계속 안걸리고 데이터를 오염시켜감.
이게 며칠 지나서 다른영역에 보일때까지 오염이 진행되면, 엉뚱한데서 크래쉬가 나서 원인을 찾기가 어려워짐. //루키스는 7년전의 오류가 자기 신입일때 터졌다함.

*과 &의 사용법으로, 포인터의 위치를 잘못설정해서, 스택메모리를 오염시키는 실습을 해봤다. //함수 안에서만 유효한 포인터를 밖으로 넘겨버린것
주소값을 다룰때는, 그 주소가 끝까지 유효한지(스택에 생성되면 사라질수도 있으니까) 생각해봐야함.
어지간해서는 스택과 관련된 데이터주소를 리턴하는 행위는 조심해야됨.
=> 데이터의 생명주기를 잘 확인해라

[ 파일 분할 관리 ] 포인터와 연관은 없지만, 앞으로 더 나아가려면 슬슬 알아야함.
헤더파일과, 그 헤더파일의 기능을 구현하는 cpp파일을 만들면된다. //한코드에서 함수를 먼저 선언하고, 기능을 아래에다 구현했던것처럼.
#include <"HeadFile.h"> 을 통해 사용할곳에서 해당 함수의 존재를 알리면된다.

주의점 : 같은이름의 함수의 기능을 여러 cpp파일에 쓰면, 코딩 단계에서는 에러처리가 나지않는다. 빌드에서 실패로 떠서 알아보기 힘드므로,
같은이름의 함수기능을 여러개 만들지 않도록 조심해라.(그래도 오버로딩은 괜찮을듯?)

만약 헤더에 struct같은 형식의 재정의가 생기면 문제가 생긴다. 그래서 헤더의 include가 여러번이 되면 문제가 생기는데,
#pragma once 를 통해, 한번 헤더가 등록되면, 똑같은 헤더를 중복되게 등록하는 행위를 막을수있다.
//이게 헤더파일을 포함하는 헤더파일을 사용하는 경우가 있기에, 헤더가 중복되는 경우가 은근히 많다. 그래서 #pragma once를 알아둬야한다.
그런데 이게 공식문법은 아니다. 옛날방법으로는 #ifndef #define #endif 로 정의되지 않으면 정의하는 방법이 있다. 쓸준몰라도 알아는둬라.
