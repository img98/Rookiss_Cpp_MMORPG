[ 데이터 기초 ]
프로그래밍? = 데이터를 잘 저장하고, 꺼내서 가공하는 것.
그럼 데이터 저장은 어떻게 할것이냐? => 컴퓨터가 데이터를 저장하는 방법을 알아보자 (비트, 바이트)
//SASM에서는 주석을 ;로 단다. //주석 => ;주석
2진수에서 음수 찾는법 = 2의 보수를 이용(어려운건 아니니 궁금하면 검색ㄱ)
! 핵심 : 비트,바이트, 진수의 이해와 진수간 변환(2진수,16진수)

[ 레지스터 기초 ]
레지스터와 메모리사이에 데이터가 이동하는 방법을 알아보겠다.(CPU레지스터 - 메모리RAM)
64bit = 8byte = 4word = 2dword = 1qword //double, quadra word
레지스터를 왜 배워야되냐? = 빠르게 업무를 처리하기 위해서는 CPU의 메모리인 레지스터에 있는 데이터를 사용하는게 좋음. 그리고 코드에도 레지스터에 관련된 커맨드가 많다.(아마 포인터 같은거 말하는듯)

레지스터의 사용부위 이름 : 레지스터의 크기는 기본적으로 최대 64비트, 이걸 다쓰면 rax, 절반만 eax (32), 그반ax (16), 여기서 또 반을 ah, al 라고 하더라.
//참고로 레지스터는 abcd, 4개의 저장소가 있어, rax, rbx 이런식으로 표현한다.

<기본적인 명령어 >
mov reg1, 0x1234 //reg1에다가 값을 넣겠다는뜻
예시 : mov eax, 0x1234 이런식으로 위에서말한 eax라는 32비트 레지스트리에 0x1234라는 값을 넣겠다.
잘못된 예시 : move cl, 0xffffffff //문법적으로는 맞으나, cl은 8비트 저장밖에 하지못하기에, 그보다 큰 바이트밸류를 갖는 값을 넣으니 에러가 날것임  //사실 이런 데이터 영역은 나중에 c++할때 또 배울것
주목할점 예시 : move eax, 0x1234 후에 move al, 0x00을 하면 eax의 값은 0x1200이 된다. 왜나면 al이 레지스트리 a의 하위 8비트 영역에만 간섭하였기에, 그 상위인 0x12..에는 영향을 주지 못한것임.

<mov의 버전>
1. mov rax, a //a라는 바구니의 주소값을 rax에 복사
2. mov rax, [a] /a바구니 안에 들어있는 값을 rax에 복사

[ 변수와 레지스터 ]
메모리와 레지스터의 관계를 알아보자.
1. section .data 
초기화 된 데이터를 사용하는 영역 : [변수이름] [크기] [초기값] //이런식으로 변수를 선언할 수 있음 ex : a db 0x11 //크기 db(Definite Byte), dw, dd, dq  각각 1,2,4,8바이트 의미
( 참고로 16진수 두자리는 8비트가 된다, 2진수변형할때, 2진수 4자리가 16진수 1자리가 되는걸 생각하면 이해하기 쉬울듯, 2진수는 1자리가 1비트니까 )  //16진수 한자리는 4비트
2. section .bss
초기화 되지 않은 데이터를 사용 :  [변수이름] [크기] [갯수] // 크기 : resb, resw, resd, resq /1,2,4,8
 e resb 10 //1바이트 변수인 e를 10개 만들겠다는 뜻. 바구니만 만드는 개념인가보네. 이렇게하면 10개의 e는 초기값이 그저 0으로 설정된다고한다.

위 둘을 왜 구분해서 사용할까? 초기화 되었냐 안되었냐의 차이인데.
=> 파일을 만들때,  bss를 사용하면, 변수의 초기값을 따로 설정해줄 필요가 없으니 실행파일의 용량이 줄어들 것이다.

나아가 레지스터와 메모리의 데이터 교환에서, 레지스터의 rax, al이런것 모두에 주소가 있듯이
메모리에 등록한 변수들에도 해당되는 주소가 있고, 만약 변수 a에다가 값을 넣는다했을때, 처음 지정해준 a의 크기 이상의 데이터를 넣어버리면, a의 영역을 초과해서 옆에 있는 b까지 침범해 버릴 수 있다.

[ 문자와 엔디안 ]
// 사실 a db 0x11 할때, a라는 바구니에 담는다 생각하지말고, 데이터를 담는 공간의, 시작주소를 a라 명명한다 생각하는게 나을듯? 

엔디안 = 메모리 주소에 데이터를 넣을때에는 리틀 엔디안과 빅 엔디안이라는 것이 있따.
빅 엔디안의 경우, 처음 시작하는 메모리 주소부터 차곡차고 값을 채워 넣는다.
리틀 엔디안의 경우, 마지막 주소(높은 주소 ex.0x103)부터 넣는다고 생각하면 된다.
0x12345678을 넣는다하면, 빅 = 0x12, 0x34,.... / 리틀 = 0x78, 0x56, ....
서버간 엔디안 사용방법이 다르다면 문제가 될 수도 있다. 
근데 왜 엔디안의 사용법이 두개나 있을까? => 장단점이 있음 //사실 이걸 알 필요는 없고 그냥 그렇다정도만..

리틀 엔디언의 경우 : 캐스팅에 유리하다. = 큰데이터에서 작은데이터사이즈로 바꾸고싶을때, ex)1바이트에서 1비트로 바꾸고 싶으면 , 앞에있는 123456은 날리고 78만 남겨야 된다.
		 그런데 리틀 같은 경우는 주소의 맨앞에 78이 있으니, 이거만 가져오면되서 빠르다. (빅의 경우 맨뒤에 78이 있으니 다 찾아가야되서 느림)
빅 엔디언의 경우 : 숫자 비교에 유리하다. 123이랑 098이랑 비교한다면, 맨 앞에 있는 1과 0의 대소차이만 비교하면 되니 빠르다. 

[ 사칙연산 ]
어셈블리에서의 사칙연산을 알아보자.
GET_DEC, PRINT_DEC 막 이런거 쓰는데, 사실 SASM은 다신 쓸일 없으니 굳이 외우진마라. 
<더하기>
add a, b를 할때 a는 레지스터/메모리 일수있고, b는 레지스터/메모리/상수일 수 있다.
 그러나 a,b모두 메모리일수는 없다.
<빼기>
sub a, b 인데 이론은 add와 같다.
<곱하기>
mul reg
왠지는 모르겠는데, mul bl만 치면 알아서 al * bl 이 연산되고 결과가 ax에 담긴다고한다.
<나누기>
div reg
 똑같이 div bl => ax/bl가 되고 연산 결과는 al에 몫, ah에는 나머지가 담긴다

//그냥 곱셈 나눗셈은 까다로운 규칙이 있다정도만 알아두자. 이해하려들지마라.
근데 위 사칙연산 기호는 c++에서도 디버깅에 자주 나온다.

[ 시프트 연산과 논리 연산 ]
< 쉬프트(shift) > : 비트 연산에서 모든 값들의 자리를 옆으로 움직이게 한다.  // shl, shr 딱봐도 왼쪽 오른쪽이네
주의할점 : 만약 -부호라서 맨앞자리에 1이 있다면 얘도 움직임? => 부호를 담당하는 맨앞자리는 변하지 않는다.
참고로 옆으로 움직이는데 옆에 공간이 없는 애들은, 그대로 사라지게 된다.  그래서 1111 1111 이라는 녀석을 왼쪽으로 4칸 오른쪽으로 4칸 움직여 제자리로 오게해도,  그대로 나오는게 아니라 0000 1111이 된다.

곱셈, 나눗셈에 쓰기도 좋고, 게임서버에서 Object ID를 만들때도 유용하다(패킷직렬화 할때, segment내의 위치가 중요했듯이, 데이터의 자리를 옮길때 사용하기 좋다.)

< 논리(logical) >
NOT : not A : A가 True면 
AND : A and B : A와 둘다 True여야 True를 반환. 하나라도 False면 False
OR : A or B : A와 B중 하나만 True여도 True를 반환, 둘다 False여야지 False 반환 
XOR : A xor B : A와 B가 달라야 True, 같으면 False반환 // OR이 있지만 OR연산과는 전혀무관

두 수의 비트 단위를 통해 숫자 논리 연산이 가능하다. 각 자리의 0과 1을 이용하여 계산하는 것임. ex. and 0, 8 => and 0b0000, 0b1000 = 0b0111 = 7이 될것임 / not 4 = not 0b0100 = 0b1011 = 11
각자리 비트의 변환이 중요한 예시 : bitflag(비트플래그) = 비트단위에다가 의미를 부여하는거임. 첫번째 비트는 fly여부, 2번째 비트는 뛸수있는지여부, ..  라고 정하면, 
나중에 주어진 데이터의 앞을 볼 필요도 없이 ...11만으로 뛰고 날수있다는 것을 알 수 있다.

xor의 논리연산의 특징 : xor로 같은 값을 두번 연산해주면, 원래 자기 형태를 찾을 수 있다. 즉, 암호화에 능하다는 것!
=> 간단한 '2' 라는 숫자에 '9xnjk2d' 이런 말도안되는 암호화 키를 곱하면 무언가 수가 나올것이다. 여기다가 다시 암호화 키를 곱하면 2가 튀어나옴
그리고 독특한 점이 자기와 동일한 값과 xor을 하면 0이 나옴. (그야 xor은 자기랑 같으면 false를 반환하니까), 이것이 mov al, 0과 같은 결과를 갖고오지만, xor이 연산로직으로 인해 더 빠르다고한다.
나중에 컴파일러를 보면 0을 대입할때 xor al, al 이런식으로 자주나올거라하더라.

[ 분기문 ]
어셈블리 언어에서의 분기문(if)은 하나의 명령어가 있는게 아니라서, 여러 코드를 조합해야함 ( 조건 체크 -> 흐름 제어 )
1. 조건을 체크
CMP dst, src (dst가 기준) : 비교를 한 결과물은 Flag Register에 저장된다. // 실습시 eflags에 들어가더라. 
2. 흐름 제어
JMP [label] 시리즈
: JMP JE JNE JG JGE.... // ~~하면 점프해라

cmp와 jmp를 붙여서 사용하여, 비교->제어를 하더라.

!특이점 : jmp를 사용하면 특정 조건일때, 특정 위치로 이동할 수 있어 if의 구현은 편리하다. 그러나 jmp는 말그대로 이동이기에, 조건을 만족하지 않는다고해서 해당 부분을 무시하진 않는다.
말그대로 위에서 쭉 룷고 가며 코드가 실행되기에, 나오는 순서가 늦어질뿐이다. 그래서 else를 구현하려면, 조건이 맞을때 실행될 코드 뒤에 라벨을 만들어 그곳으로 jmp하게해야한다.

< 반복문 >
특정 조건을 만족할때까지 반복해서 실행하는것이다.
간단하게 Hello world를 10번 찍는 반복문을 생각해보면, 문장을 찍고 그후에 jmp를 통해 다시 위로 올라가면 될것이다. (그러면 다시 문장을 찍고 위로 올라가는 jmp가 나올것임)
그리고 count를 기록해서 10번 찍으면 '위로 올라가는 jmp의' '밑으로 가는 jmp'를 쓰면될것이다. 아니면 count를 보고 jne라는 점프시리즈를 써도된다(jne=더 작으면 jmp시킨다)

사실 cmp jmp말고도 어셈블리에 loop라는 반복문 명령어도 있다. loop [라벨] 인데, ecx에 루프가 돌 횟수를 관리하고, loop의 내부적으로 ecx를 1줄이는 로직이 있어, 감소를 따로 구현하지 않아도 된다.

[ 배열과 주소 ]
배열 : a db 0x01, 0x02, 0x03 ... 이런식으로 배열을 만들수도 있고, b times 5 dw 1 로도 만들수 있다.(5개, 2바이트짜리)
여기서 a는 배열의 시작점의 주소를 의미한다. 그럼 a주소에 +1을해주면 0x02라는 다음 인덱스가 나온다.

C++에는 이렇게 주소에다 덧셈을해서 주소를 불러오는 경우가 굉장히 많기에, 주소의 개념을 이해하는게 중요하다.

[ 함수 기초 ]
어셈블리 언어에서는 프로시저(procedure) 또는 서브루틴(subroutine)이라는 용어를 쓰는데, 대부분 언어에서는 함수라하니 걍 함수라고 명하겠다.
call로 함수를 호출하는데 마치 jmp와 같은 형태더라. 
함수가 중요한 이유는, 인자를 넣어서 결과를 반환할 수 있다는 것인데, 이걸 레지스터 개념과 함께 생각해보자.
우리가 그동안 eax, ebx c d 에 값을 넣어서 코드를 짰는데, 인자가 워낙 많아서 레지스터 abcd가 부족하면 어떻게 될까? =못함.
메모리를 사용하면 되지않나? => 휘발적으로 사용하는 변수의 특성상 메모리에 담으면 낭비가 심함.

=> 결국, 레지스터, data섹션, bss섹션으로는 해결할 수 없기에, 새로운 형태의 메모리영역, Stack이 등장했다.
( 메모리에 일시적으로 데이터를 담을 범위를 유동적으로 설정하고 사용 후 처리한다. )

[ 스택 메모리 ]
메모리 저장구조 : 코드-데이터-BSS-힙-스택 //이제 깨달은건데, 여기서의 data와bss가 아까 section에서의 그것들이다.

<레지스터의 용도>
1. a b c d 범용 레지스터
2. 포인터 레지스터
3. ip (Insturction Pointer) : 다음 수행 명령어의 위치
4. sp (Stack Pointer) : 현재 스택의 Top 위치 (일종의 Curor)
5. bp (Base Pointer) : 스택 상대주소 계산용

함수의 호출을 스택 메모리의 관점으로 보면
push rbp ; mov rbpm rsp ; pop rbp ; ret 이 된다. 즉, 메모리에 rbp(bp)를 불러오고, 거기다가 rsp(현재sp)의 주소를 넣는다. 그리고 업무수행 후 rbp를 꺼내
원래코드의 위치로 돌아가게 된다. //sp는 계속 변하니까 bp라는 베이스 포인트를 잡아놓는것이다. 이 bp가 해당 함수에서 사용하는 임시적 할당영역을 표시하는 것이다.

이렇게 sp와 bp를 사용하며 스택메모리의 공간을 이동하는 기술을 스택 프레임이라고 한다.
