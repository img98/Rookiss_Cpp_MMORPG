[ 함수기초 ] 함수, 프로시저, 메소드, 루틴 여러이름으로 불린다.
사실 int man( ) 함수도 return 0이 있는데, 생략해도 된다. //메인만 생략 가능한듯

[ 스택 프레임 ]
F5는 중단점까지 쭉 실행, F11은 코드 한줄한줄 실행
F10은 프로시자(함수) 단위로 실행. 즉, 실행되고 있는 코드 필드에서 '호출하는 함수' 내부로까진 가지 않겠다.

스택메모리 : 높은주소부터 <1.매개변수(인풋) - 2.리턴주소값 - 3.지역변수><1.매개변수(인풋) - 2.리턴주소값 - 3.지역변수> 의 순으로 쌓이게 된다.

c++은 메모리 주소에 직접 접근이 가능해서 알아둬야한다.

[ 지역변수와 값 전달 ]
그냥 같은 함수에서 호출하더라도, 지역변수와 호출한 함수의 인자는 다른 주소값을 갖는다는 말인듯?
위 스택프레임에서 보듯이, 1.매개변수 와 3.지역변수의 주소는 다르니까
함수내에서의 값을 전달하려면, return을 사용하는데, 이건 호출한 함수내의 지역변수에 temp값을 만들고 그걸 return주소로 보내준다는 의미인듯.
//당연한걸 너무 어렵게 말하는 것 같아서 좀 상세히 써봄.

[ 호출 스택 ]
함수에서 다른함수를 호출하는 실습. c++의 경우 좀 멍청해서, 호출하는 함수가, 코드의 윗줄에 없으면 찾질못함.
그런데 코드에서 위치를 맞춰주진 않고, 그냥 함수의 이름과 인자 만을 선언해주면 된다. //내생각에 함수호출에서 매개변수의 주소값을 할당시킬때, 몇비트나 줘야될지 알아야되서 생기는 문제인듯!
=> 그래서 C++에서는 함수의 선언부와 기능구현부가 따로 만들게될것임.

호출 스택 : 나(함수)를 호출한 곳이 어디인지(내가 누구에 의해 작동하는지) 알 수 있게한다. //F5디버그 누르면 우측하단에 있을것임.
이게 반환주소값들을 다 보여주는것임. => 이걸통해 코드의 흐름을 빠르게 알 수 있다. 프로그래머의 평생을 같이할 기능임.

[ 함수 마무리 ]
1. 오버로딩 : 함수이름의 재사용
함수의 매개변수(인자) 갯수가 다르거나, 타입이 다르면, 이름이 같은 다른 함수인것으로 취급

[ TextRPG ]
struct의 내용물의 크기가 11바이트라 해도, 실제 컴파일러에서는 해당 구조체에 대한 크기를 16바이트로 볼 수 있다.
=> 컴파일러가, 자기가 계산하기 편하게 빈값을 넣는것임. (패딩)




 
 

